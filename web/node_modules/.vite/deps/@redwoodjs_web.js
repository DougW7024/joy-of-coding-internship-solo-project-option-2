import {
  require_FetchConfigProvider,
  require_GraphQLHooksProvider,
  require_apollo
} from "./chunk-ROONVCXJ.js";
import "./chunk-UULRR4A2.js";
import {
  require_entries,
  require_every,
  require_flat_map,
  require_flatten_into_array,
  require_is_array as require_is_array2,
  require_values
} from "./chunk-NQ4HX6PO.js";
import {
  require_filter,
  require_includes
} from "./chunk-NRNE6G5O.js";
import {
  require_for_each,
  require_keys
} from "./chunk-7SMCR6UX.js";
import {
  require_stringify
} from "./chunk-ZNUYSFG4.js";
import {
  require_global_this
} from "./chunk-RVSKRULQ.js";
import {
  require_interopRequireWildcard
} from "./chunk-VFI5UTAZ.js";
import {
  require_map
} from "./chunk-AZP2HYDB.js";
import {
  require_add_to_unscopables
} from "./chunk-76PFQ7MX.js";
import {
  require_jsx_runtime
} from "./chunk-KWOHGQDJ.js";
import "./chunk-YQYSMPXZ.js";
import "./chunk-VYX2O666.js";
import {
  require_interopRequireDefault
} from "./chunk-NRWAR2OR.js";
import {
  require_array_species_create,
  require_define_property2 as require_define_property,
  require_export,
  require_function_uncurry_this,
  require_get_built_in_prototype_method,
  require_is_array,
  require_length_of_array_like,
  require_object_is_prototype_of,
  require_to_integer_or_infinity,
  require_to_object
} from "./chunk-X6KK2XJU.js";
import {
  require_react
} from "./chunk-TG2HHWBU.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-2GTGKKMZ.js";

// ../node_modules/@redwoodjs/web/dist/global.web-auto-imports.js
var require_global_web_auto_imports = __commonJS({
  "../node_modules/@redwoodjs/web/dist/global.web-auto-imports.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// ../node_modules/@redwoodjs/web/dist/config.js
var require_config = __commonJS({
  "../node_modules/@redwoodjs/web/dist/config.js"() {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    var _globalThis2 = _interopRequireDefault(require_global_this());
    _globalThis2.default.RWJS_API_GRAPHQL_URL = RWJS_ENV.RWJS_API_GRAPHQL_URL;
    _globalThis2.default.RWJS_API_URL = RWJS_ENV.RWJS_API_URL;
    _globalThis2.default.__REDWOOD__APP_TITLE = RWJS_ENV.__REDWOOD__APP_TITLE;
  }
});

// ../node_modules/@redwoodjs/web/dist/assetImports.js
var require_assetImports = __commonJS({
  "../node_modules/@redwoodjs/web/dist/assetImports.js"() {
    "use strict";
  }
});

// ../node_modules/@redwoodjs/web/dist/components/FatalErrorBoundary.js
var require_FatalErrorBoundary = __commonJS({
  "../node_modules/@redwoodjs/web/dist/components/FatalErrorBoundary.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property();
    var _interopRequireDefault = require_interopRequireDefault().default;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireDefault(require_react());
    var _jsxRuntime = require_jsx_runtime();
    var InfallibleErrorBoundary = class extends _react.default.Component {
      constructor() {
        super(...arguments);
        this.state = {
          hasError: false
        };
      }
      static getDerivedStateFromError() {
        return {
          hasError: true
        };
      }
      render() {
        if (this.state.hasError) {
          return (0, _jsxRuntime.jsx)("h1", {
            children: "Something went wrong and we are unable to show this page."
          });
        }
        return this.props.children;
      }
    };
    var FatalErrorBoundary = class extends _react.default.Component {
      constructor() {
        super(...arguments);
        this.state = {
          hasError: false,
          error: void 0
        };
      }
      static getDerivedStateFromError(error) {
        return {
          hasError: true,
          error
        };
      }
      render() {
        const {
          page: Page
        } = this.props;
        if (this.state.hasError) {
          return (0, _jsxRuntime.jsx)(InfallibleErrorBoundary, {
            children: (0, _jsxRuntime.jsx)(Page, {
              error: this.state.error
            })
          });
        }
        return this.props.children;
      }
    };
    var _default = exports.default = FatalErrorBoundary;
  }
});

// ../node_modules/@redwoodjs/web/dist/components/CellCacheContext.js
var require_CellCacheContext = __commonJS({
  "../node_modules/@redwoodjs/web/dist/components/CellCacheContext.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property();
    var _interopRequireWildcard = require_interopRequireWildcard().default;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CellCacheContextProvider = void 0;
    exports.useCellCacheContext = useCellCacheContext;
    var _react = _interopRequireWildcard(require_react());
    var _jsxRuntime = require_jsx_runtime();
    var CellCacheContext = (0, _react.createContext)(void 0);
    var CellCacheContextProvider = (_ref) => {
      let {
        queryCache,
        children
      } = _ref;
      return (0, _jsxRuntime.jsx)(CellCacheContext.Provider, {
        value: {
          queryCache
        },
        children
      });
    };
    exports.CellCacheContextProvider = CellCacheContextProvider;
    function useCellCacheContext() {
      const context = (0, _react.useContext)(CellCacheContext);
      if (!context) {
        throw new Error("useCellCacheContext must be used within a CellCacheContextProvider");
      }
      return context;
    }
  }
});

// ../node_modules/@redwoodjs/web/dist/graphql.js
var require_graphql = __commonJS({
  "../node_modules/@redwoodjs/web/dist/graphql.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getOperationName = getOperationName;
    function getOperationName(document2) {
      var _a3;
      for (const definition of document2.definitions) {
        if (definition.kind === "OperationDefinition" && ((_a3 = definition.name) == null ? void 0 : _a3.value)) {
          return definition.name.value;
        }
      }
      return "";
    }
  }
});

// ../node_modules/@redwoodjs/web/dist/components/createCell.js
var require_createCell = __commonJS({
  "../node_modules/@redwoodjs/web/dist/components/createCell.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property();
    var _interopRequireDefault = require_interopRequireDefault().default;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createCell = createCell;
    var _isArray = _interopRequireDefault(require_is_array2());
    var _every = _interopRequireDefault(require_every());
    var _values = _interopRequireDefault(require_values());
    var _globalThis2 = _interopRequireDefault(require_global_this());
    var _stringify = _interopRequireDefault(require_stringify());
    var _apollo = require_apollo();
    var _graphql = require_graphql();
    var _CellCacheContext = require_CellCacheContext();
    var _GraphQLHooksProvider = require_GraphQLHooksProvider();
    var _jsxRuntime = require_jsx_runtime();
    function isFieldEmptyArray(field) {
      return (0, _isArray.default)(field) && field.length === 0;
    }
    function isDataEmpty(data) {
      var _context;
      return (0, _every.default)(_context = (0, _values.default)(data)).call(_context, (fieldValue) => {
        return fieldValue === null || isFieldEmptyArray(fieldValue);
      });
    }
    function createCell(_ref) {
      let {
        QUERY,
        beforeQuery = (props) => ({
          // By default, we assume that the props are the gql-variables.
          variables: props,
          /**
           * We're duplicating these props here due to a suspected bug in Apollo Client v3.5.4
           * (it doesn't seem to be respecting `defaultOptions` in `RedwoodApolloProvider`.)
           *
           * @see {@link https://github.com/apollographql/apollo-client/issues/9105}
           */
          fetchPolicy: "cache-and-network",
          notifyOnNetworkStatusChange: true
        }),
        afterQuery = (data) => ({
          ...data
        }),
        isEmpty = isDataEmpty,
        Loading = () => (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
          children: "Loading..."
        }),
        Failure,
        Empty,
        Success,
        displayName = "Cell"
      } = _ref;
      function NamedCell(props) {
        var _a3, _b, _c;
        const {
          children: _,
          ...variables
        } = props;
        const options = beforeQuery(variables);
        const query = typeof QUERY === "function" ? QUERY(options) : QUERY;
        let {
          // eslint-disable-next-line prefer-const
          error,
          loading,
          data,
          ...queryResult
        } = (0, _GraphQLHooksProvider.useQuery)(query, options);
        if (_globalThis2.default.__REDWOOD__PRERENDERING) {
          const {
            queryCache
          } = (0, _CellCacheContext.useCellCacheContext)();
          const operationName = (0, _graphql.getOperationName)(query);
          const transformedQuery = _apollo.fragmentRegistry.transform(query);
          let cacheKey;
          if (operationName) {
            cacheKey = operationName + "_" + (0, _stringify.default)(variables);
          } else {
            const cellName = displayName === "Cell" ? "the cell" : displayName;
            throw new Error(`The gql query in ${cellName} is missing an operation name. Something like FindBlogPostQuery in \`query FindBlogPostQuery($id: Int!)\``);
          }
          const queryInfo = queryCache[cacheKey];
          if (queryInfo == null ? void 0 : queryInfo.renderLoading) {
            loading = true;
          } else {
            if (queryInfo == null ? void 0 : queryInfo.hasProcessed) {
              loading = false;
              data = queryInfo.data;
              queryResult = {
                variables
              };
            } else {
              queryCache[cacheKey] || (queryCache[cacheKey] = {
                query: transformedQuery,
                variables: options.variables,
                hasProcessed: false
              });
            }
          }
        }
        if (error) {
          if (Failure) {
            var _errorCode;
            return (0, _jsxRuntime.jsx)(Failure, {
              error,
              errorCode: (
                // Use the ad-hoc QueryResultWithErrorCode type to access the errorCode
                (_errorCode = queryResult.errorCode) !== null && _errorCode !== void 0 ? _errorCode : (_c = (_b = (_a3 = error.graphQLErrors) == null ? void 0 : _a3[0]) == null ? void 0 : _b.extensions) == null ? void 0 : _c["code"]
              ),
              ...props,
              updating: loading,
              queryResult
            });
          } else {
            throw error;
          }
        } else if (data) {
          const afterQueryData = afterQuery(data);
          if (isEmpty(data, {
            isDataEmpty
          }) && Empty) {
            return (0, _jsxRuntime.jsx)(Empty, {
              ...props,
              ...afterQueryData,
              updating: loading,
              queryResult
            });
          } else {
            return (0, _jsxRuntime.jsx)(Success, {
              ...props,
              ...afterQueryData,
              updating: loading,
              queryResult
            });
          }
        } else if (loading) {
          return (0, _jsxRuntime.jsx)(Loading, {
            ...props,
            queryResult
          });
        } else {
          console.warn(`If you're using Apollo Client, check for its debug logs here in the console, which may help explain the error.`);
          throw new Error("Cannot render Cell: reached an unexpected state where the query succeeded but `data` is `null`. If this happened in Storybook, your query could be missing fields; otherwise this is most likely a GraphQL caching bug. Note that adding an `id` field to all the fields on your query may fix the issue.");
        }
      }
      NamedCell.displayName = displayName;
      return (props) => {
        return (0, _jsxRuntime.jsx)(NamedCell, {
          ...props
        });
      };
    }
  }
});

// ../node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "../node_modules/react-fast-compare/index.js"(exports, module) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        var it;
        if (hasMap && a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0]))
              return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!equal(i.value[1], b.get(i.value[0])))
              return false;
          return true;
        }
        if (hasSet && a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0]))
              return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (a[i] !== b[i])
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b.valueOf === "function")
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b.toString === "function")
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        if (hasElementType && a instanceof Element)
          return false;
        for (i = length; i-- !== 0; ) {
          if ((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) {
            continue;
          }
          if (!equal(a[keys[i]], b[keys[i]]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }
    module.exports = function isEqual(a, b) {
      try {
        return equal(a, b);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
  }
});

// ../node_modules/invariant/browser.js
var require_browser = __commonJS({
  "../node_modules/invariant/browser.js"(exports, module) {
    "use strict";
    var invariant2 = function(condition, format, a, b, c, d, e, f) {
      if (true) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant2;
  }
});

// ../node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "../node_modules/shallowequal/index.js"(exports, module) {
    module.exports = function shallowEqual2(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../node_modules/react-helmet-async/lib/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  Helmet: () => Helmet,
  HelmetData: () => HelmetData,
  HelmetProvider: () => HelmetProvider
});
var import_react, import_react_fast_compare, import_invariant, import_react2, import_react3, import_react4, import_shallowequal, TAG_NAMES, SEO_PRIORITY_TAGS, VALID_TAG_NAMES, REACT_TAG_MAP, HTML_TAG_MAP, HELMET_ATTRIBUTE, HELMET_PROPS, getInnermostProperty, getTitleFromPropsList, getOnChangeClientState, getAttributesFromPropsList, getBaseTagFromPropsList, warn, getTagsFromPropsList, getAnyTrueFromPropsList, reducePropsToState, flattenArray, checkIfPropsMatch, prioritizer, without, SELF_CLOSING_TAGS, encodeSpecialCharacters, generateElementAttributesAsString, generateTitleAsString, generateTagsAsString, convertElementAttributesToReactProps, generateTitleAsReactComponent, generateTagsAsReactComponent, getMethodsForTag, getPriorityMethods, mapStateOnServer, server_default, instances, isDocument, HelmetData, defaultValue, Context, _a, HelmetProvider, updateTags, updateAttributes, updateTitle, commitTagChanges, _helmetCallback, handleStateChangeOnClient, client_default, HelmetDispatcher, _a2, Helmet;
var init_index_esm = __esm({
  "../node_modules/react-helmet-async/lib/index.esm.js"() {
    import_react = __toESM(require_react());
    import_react_fast_compare = __toESM(require_react_fast_compare());
    import_invariant = __toESM(require_browser());
    import_react2 = __toESM(require_react());
    import_react3 = __toESM(require_react());
    import_react4 = __toESM(require_react());
    import_shallowequal = __toESM(require_shallowequal());
    TAG_NAMES = ((TAG_NAMES2) => {
      TAG_NAMES2["BASE"] = "base";
      TAG_NAMES2["BODY"] = "body";
      TAG_NAMES2["HEAD"] = "head";
      TAG_NAMES2["HTML"] = "html";
      TAG_NAMES2["LINK"] = "link";
      TAG_NAMES2["META"] = "meta";
      TAG_NAMES2["NOSCRIPT"] = "noscript";
      TAG_NAMES2["SCRIPT"] = "script";
      TAG_NAMES2["STYLE"] = "style";
      TAG_NAMES2["TITLE"] = "title";
      TAG_NAMES2["FRAGMENT"] = "Symbol(react.fragment)";
      return TAG_NAMES2;
    })(TAG_NAMES || {});
    SEO_PRIORITY_TAGS = {
      link: { rel: ["amphtml", "canonical", "alternate"] },
      script: { type: ["application/ld+json"] },
      meta: {
        charset: "",
        name: ["generator", "robots", "description"],
        property: [
          "og:type",
          "og:title",
          "og:url",
          "og:image",
          "og:image:alt",
          "og:description",
          "twitter:url",
          "twitter:title",
          "twitter:description",
          "twitter:image",
          "twitter:image:alt",
          "twitter:card",
          "twitter:site"
        ]
      }
    };
    VALID_TAG_NAMES = Object.values(TAG_NAMES);
    REACT_TAG_MAP = {
      accesskey: "accessKey",
      charset: "charSet",
      class: "className",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      "http-equiv": "httpEquiv",
      itemprop: "itemProp",
      tabindex: "tabIndex"
    };
    HTML_TAG_MAP = Object.entries(REACT_TAG_MAP).reduce(
      (carry, [key, value]) => {
        carry[value] = key;
        return carry;
      },
      {}
    );
    HELMET_ATTRIBUTE = "data-rh";
    HELMET_PROPS = {
      DEFAULT_TITLE: "defaultTitle",
      DEFER: "defer",
      ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
      ON_CHANGE_CLIENT_STATE: "onChangeClientState",
      TITLE_TEMPLATE: "titleTemplate",
      PRIORITIZE_SEO_TAGS: "prioritizeSeoTags"
    };
    getInnermostProperty = (propsList, property) => {
      for (let i = propsList.length - 1; i >= 0; i -= 1) {
        const props = propsList[i];
        if (Object.prototype.hasOwnProperty.call(props, property)) {
          return props[property];
        }
      }
      return null;
    };
    getTitleFromPropsList = (propsList) => {
      let innermostTitle = getInnermostProperty(
        propsList,
        "title"
        /* TITLE */
      );
      const innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);
      if (Array.isArray(innermostTitle)) {
        innermostTitle = innermostTitle.join("");
      }
      if (innermostTemplate && innermostTitle) {
        return innermostTemplate.replace(/%s/g, () => innermostTitle);
      }
      const innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);
      return innermostTitle || innermostDefaultTitle || void 0;
    };
    getOnChangeClientState = (propsList) => getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || (() => {
    });
    getAttributesFromPropsList = (tagType, propsList) => propsList.filter((props) => typeof props[tagType] !== "undefined").map((props) => props[tagType]).reduce((tagAttrs, current) => ({ ...tagAttrs, ...current }), {});
    getBaseTagFromPropsList = (primaryAttributes, propsList) => propsList.filter((props) => typeof props[
      "base"
      /* BASE */
    ] !== "undefined").map((props) => props[
      "base"
      /* BASE */
    ]).reverse().reduce((innermostBaseTag, tag) => {
      if (!innermostBaseTag.length) {
        const keys = Object.keys(tag);
        for (let i = 0; i < keys.length; i += 1) {
          const attributeKey = keys[i];
          const lowerCaseAttributeKey = attributeKey.toLowerCase();
          if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
            return innermostBaseTag.concat(tag);
          }
        }
      }
      return innermostBaseTag;
    }, []);
    warn = (msg) => console && typeof console.warn === "function" && console.warn(msg);
    getTagsFromPropsList = (tagName, primaryAttributes, propsList) => {
      const approvedSeenTags = {};
      return propsList.filter((props) => {
        if (Array.isArray(props[tagName])) {
          return true;
        }
        if (typeof props[tagName] !== "undefined") {
          warn(
            `Helmet: ${tagName} should be of type "Array". Instead found type "${typeof props[tagName]}"`
          );
        }
        return false;
      }).map((props) => props[tagName]).reverse().reduce((approvedTags, instanceTags) => {
        const instanceSeenTags = {};
        instanceTags.filter((tag) => {
          let primaryAttributeKey;
          const keys2 = Object.keys(tag);
          for (let i = 0; i < keys2.length; i += 1) {
            const attributeKey = keys2[i];
            const lowerCaseAttributeKey = attributeKey.toLowerCase();
            if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === "rel" && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === "rel" && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
              primaryAttributeKey = lowerCaseAttributeKey;
            }
            if (primaryAttributes.indexOf(attributeKey) !== -1 && (attributeKey === "innerHTML" || attributeKey === "cssText" || attributeKey === "itemprop")) {
              primaryAttributeKey = attributeKey;
            }
          }
          if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
            return false;
          }
          const value = tag[primaryAttributeKey].toLowerCase();
          if (!approvedSeenTags[primaryAttributeKey]) {
            approvedSeenTags[primaryAttributeKey] = {};
          }
          if (!instanceSeenTags[primaryAttributeKey]) {
            instanceSeenTags[primaryAttributeKey] = {};
          }
          if (!approvedSeenTags[primaryAttributeKey][value]) {
            instanceSeenTags[primaryAttributeKey][value] = true;
            return true;
          }
          return false;
        }).reverse().forEach((tag) => approvedTags.push(tag));
        const keys = Object.keys(instanceSeenTags);
        for (let i = 0; i < keys.length; i += 1) {
          const attributeKey = keys[i];
          const tagUnion = {
            ...approvedSeenTags[attributeKey],
            ...instanceSeenTags[attributeKey]
          };
          approvedSeenTags[attributeKey] = tagUnion;
        }
        return approvedTags;
      }, []).reverse();
    };
    getAnyTrueFromPropsList = (propsList, checkedTag) => {
      if (Array.isArray(propsList) && propsList.length) {
        for (let index = 0; index < propsList.length; index += 1) {
          const prop = propsList[index];
          if (prop[checkedTag]) {
            return true;
          }
        }
      }
      return false;
    };
    reducePropsToState = (propsList) => ({
      baseTag: getBaseTagFromPropsList([
        "href"
        /* HREF */
      ], propsList),
      bodyAttributes: getAttributesFromPropsList("bodyAttributes", propsList),
      defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
      encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
      htmlAttributes: getAttributesFromPropsList("htmlAttributes", propsList),
      linkTags: getTagsFromPropsList(
        "link",
        [
          "rel",
          "href"
          /* HREF */
        ],
        propsList
      ),
      metaTags: getTagsFromPropsList(
        "meta",
        [
          "name",
          "charset",
          "http-equiv",
          "property",
          "itemprop"
          /* ITEM_PROP */
        ],
        propsList
      ),
      noscriptTags: getTagsFromPropsList("noscript", [
        "innerHTML"
        /* INNER_HTML */
      ], propsList),
      onChangeClientState: getOnChangeClientState(propsList),
      scriptTags: getTagsFromPropsList(
        "script",
        [
          "src",
          "innerHTML"
          /* INNER_HTML */
        ],
        propsList
      ),
      styleTags: getTagsFromPropsList("style", [
        "cssText"
        /* CSS_TEXT */
      ], propsList),
      title: getTitleFromPropsList(propsList),
      titleAttributes: getAttributesFromPropsList("titleAttributes", propsList),
      prioritizeSeoTags: getAnyTrueFromPropsList(propsList, HELMET_PROPS.PRIORITIZE_SEO_TAGS)
    });
    flattenArray = (possibleArray) => Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
    checkIfPropsMatch = (props, toMatch) => {
      const keys = Object.keys(props);
      for (let i = 0; i < keys.length; i += 1) {
        if (toMatch[keys[i]] && toMatch[keys[i]].includes(props[keys[i]])) {
          return true;
        }
      }
      return false;
    };
    prioritizer = (elementsList, propsToMatch) => {
      if (Array.isArray(elementsList)) {
        return elementsList.reduce(
          (acc, elementAttrs) => {
            if (checkIfPropsMatch(elementAttrs, propsToMatch)) {
              acc.priority.push(elementAttrs);
            } else {
              acc.default.push(elementAttrs);
            }
            return acc;
          },
          { priority: [], default: [] }
        );
      }
      return { default: elementsList, priority: [] };
    };
    without = (obj, key) => {
      return {
        ...obj,
        [key]: void 0
      };
    };
    SELF_CLOSING_TAGS = [
      "noscript",
      "script",
      "style"
      /* STYLE */
    ];
    encodeSpecialCharacters = (str, encode = true) => {
      if (encode === false) {
        return String(str);
      }
      return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    };
    generateElementAttributesAsString = (attributes) => Object.keys(attributes).reduce((str, key) => {
      const attr = typeof attributes[key] !== "undefined" ? `${key}="${attributes[key]}"` : `${key}`;
      return str ? `${str} ${attr}` : attr;
    }, "");
    generateTitleAsString = (type, title, attributes, encode) => {
      const attributeString = generateElementAttributesAsString(attributes);
      const flattenedTitle = flattenArray(title);
      return attributeString ? `<${type} ${HELMET_ATTRIBUTE}="true" ${attributeString}>${encodeSpecialCharacters(
        flattenedTitle,
        encode
      )}</${type}>` : `<${type} ${HELMET_ATTRIBUTE}="true">${encodeSpecialCharacters(
        flattenedTitle,
        encode
      )}</${type}>`;
    };
    generateTagsAsString = (type, tags, encode = true) => tags.reduce((str, t) => {
      const tag = t;
      const attributeHtml = Object.keys(tag).filter(
        (attribute) => !(attribute === "innerHTML" || attribute === "cssText")
      ).reduce((string, attribute) => {
        const attr = typeof tag[attribute] === "undefined" ? attribute : `${attribute}="${encodeSpecialCharacters(tag[attribute], encode)}"`;
        return string ? `${string} ${attr}` : attr;
      }, "");
      const tagContent = tag.innerHTML || tag.cssText || "";
      const isSelfClosing = SELF_CLOSING_TAGS.indexOf(type) === -1;
      return `${str}<${type} ${HELMET_ATTRIBUTE}="true" ${attributeHtml}${isSelfClosing ? `/>` : `>${tagContent}</${type}>`}`;
    }, "");
    convertElementAttributesToReactProps = (attributes, initProps = {}) => Object.keys(attributes).reduce((obj, key) => {
      const mapped = REACT_TAG_MAP[key];
      obj[mapped || key] = attributes[key];
      return obj;
    }, initProps);
    generateTitleAsReactComponent = (_type, title, attributes) => {
      const initProps = {
        key: title,
        [HELMET_ATTRIBUTE]: true
      };
      const props = convertElementAttributesToReactProps(attributes, initProps);
      return [import_react3.default.createElement("title", props, title)];
    };
    generateTagsAsReactComponent = (type, tags) => tags.map((tag, i) => {
      const mappedTag = {
        key: i,
        [HELMET_ATTRIBUTE]: true
      };
      Object.keys(tag).forEach((attribute) => {
        const mapped = REACT_TAG_MAP[attribute];
        const mappedAttribute = mapped || attribute;
        if (mappedAttribute === "innerHTML" || mappedAttribute === "cssText") {
          const content = tag.innerHTML || tag.cssText;
          mappedTag.dangerouslySetInnerHTML = { __html: content };
        } else {
          mappedTag[mappedAttribute] = tag[attribute];
        }
      });
      return import_react3.default.createElement(type, mappedTag);
    });
    getMethodsForTag = (type, tags, encode = true) => {
      switch (type) {
        case "title":
          return {
            toComponent: () => generateTitleAsReactComponent(type, tags.title, tags.titleAttributes),
            toString: () => generateTitleAsString(type, tags.title, tags.titleAttributes, encode)
          };
        case "bodyAttributes":
        case "htmlAttributes":
          return {
            toComponent: () => convertElementAttributesToReactProps(tags),
            toString: () => generateElementAttributesAsString(tags)
          };
        default:
          return {
            toComponent: () => generateTagsAsReactComponent(type, tags),
            toString: () => generateTagsAsString(type, tags, encode)
          };
      }
    };
    getPriorityMethods = ({ metaTags, linkTags, scriptTags, encode }) => {
      const meta = prioritizer(metaTags, SEO_PRIORITY_TAGS.meta);
      const link = prioritizer(linkTags, SEO_PRIORITY_TAGS.link);
      const script = prioritizer(scriptTags, SEO_PRIORITY_TAGS.script);
      const priorityMethods = {
        toComponent: () => [
          ...generateTagsAsReactComponent("meta", meta.priority),
          ...generateTagsAsReactComponent("link", link.priority),
          ...generateTagsAsReactComponent("script", script.priority)
        ],
        toString: () => (
          // generate all the tags as strings and concatenate them
          `${getMethodsForTag("meta", meta.priority, encode)} ${getMethodsForTag(
            "link",
            link.priority,
            encode
          )} ${getMethodsForTag("script", script.priority, encode)}`
        )
      };
      return {
        priorityMethods,
        metaTags: meta.default,
        linkTags: link.default,
        scriptTags: script.default
      };
    };
    mapStateOnServer = (props) => {
      const {
        baseTag,
        bodyAttributes,
        encode = true,
        htmlAttributes,
        noscriptTags,
        styleTags,
        title = "",
        titleAttributes,
        prioritizeSeoTags
      } = props;
      let { linkTags, metaTags, scriptTags } = props;
      let priorityMethods = {
        toComponent: () => {
        },
        toString: () => ""
      };
      if (prioritizeSeoTags) {
        ({ priorityMethods, linkTags, metaTags, scriptTags } = getPriorityMethods(props));
      }
      return {
        priority: priorityMethods,
        base: getMethodsForTag("base", baseTag, encode),
        bodyAttributes: getMethodsForTag("bodyAttributes", bodyAttributes, encode),
        htmlAttributes: getMethodsForTag("htmlAttributes", htmlAttributes, encode),
        link: getMethodsForTag("link", linkTags, encode),
        meta: getMethodsForTag("meta", metaTags, encode),
        noscript: getMethodsForTag("noscript", noscriptTags, encode),
        script: getMethodsForTag("script", scriptTags, encode),
        style: getMethodsForTag("style", styleTags, encode),
        title: getMethodsForTag("title", { title, titleAttributes }, encode)
      };
    };
    server_default = mapStateOnServer;
    instances = [];
    isDocument = !!(typeof window !== "undefined" && window.document && window.document.createElement);
    HelmetData = class {
      constructor(context, canUseDOM) {
        __publicField(this, "instances", []);
        __publicField(this, "canUseDOM", isDocument);
        __publicField(this, "context");
        __publicField(this, "value", {
          setHelmet: (serverState) => {
            this.context.helmet = serverState;
          },
          helmetInstances: {
            get: () => this.canUseDOM ? instances : this.instances,
            add: (instance) => {
              (this.canUseDOM ? instances : this.instances).push(instance);
            },
            remove: (instance) => {
              const index = (this.canUseDOM ? instances : this.instances).indexOf(instance);
              (this.canUseDOM ? instances : this.instances).splice(index, 1);
            }
          }
        });
        this.context = context;
        this.canUseDOM = canUseDOM || false;
        if (!canUseDOM) {
          context.helmet = server_default({
            baseTag: [],
            bodyAttributes: {},
            encodeSpecialCharacters: true,
            htmlAttributes: {},
            linkTags: [],
            metaTags: [],
            noscriptTags: [],
            scriptTags: [],
            styleTags: [],
            title: "",
            titleAttributes: {}
          });
        }
      }
    };
    defaultValue = {};
    Context = import_react2.default.createContext(defaultValue);
    HelmetProvider = (_a = class extends import_react2.Component {
      constructor(props) {
        super(props);
        __publicField(this, "helmetData");
        this.helmetData = new HelmetData(this.props.context || {}, _a.canUseDOM);
      }
      render() {
        return import_react2.default.createElement(Context.Provider, { value: this.helmetData.value }, this.props.children);
      }
    }, __publicField(_a, "canUseDOM", isDocument), _a);
    updateTags = (type, tags) => {
      const headElement = document.head || document.querySelector(
        "head"
        /* HEAD */
      );
      const tagNodes = headElement.querySelectorAll(`${type}[${HELMET_ATTRIBUTE}]`);
      const oldTags = [].slice.call(tagNodes);
      const newTags = [];
      let indexToDelete;
      if (tags && tags.length) {
        tags.forEach((tag) => {
          const newElement = document.createElement(type);
          for (const attribute in tag) {
            if (Object.prototype.hasOwnProperty.call(tag, attribute)) {
              if (attribute === "innerHTML") {
                newElement.innerHTML = tag.innerHTML;
              } else if (attribute === "cssText") {
                if (newElement.styleSheet) {
                  newElement.styleSheet.cssText = tag.cssText;
                } else {
                  newElement.appendChild(document.createTextNode(tag.cssText));
                }
              } else {
                const attr = attribute;
                const value = typeof tag[attr] === "undefined" ? "" : tag[attr];
                newElement.setAttribute(attribute, value);
              }
            }
          }
          newElement.setAttribute(HELMET_ATTRIBUTE, "true");
          if (oldTags.some((existingTag, index) => {
            indexToDelete = index;
            return newElement.isEqualNode(existingTag);
          })) {
            oldTags.splice(indexToDelete, 1);
          } else {
            newTags.push(newElement);
          }
        });
      }
      oldTags.forEach((tag) => {
        var _a3;
        return (_a3 = tag.parentNode) == null ? void 0 : _a3.removeChild(tag);
      });
      newTags.forEach((tag) => headElement.appendChild(tag));
      return {
        oldTags,
        newTags
      };
    };
    updateAttributes = (tagName, attributes) => {
      const elementTag = document.getElementsByTagName(tagName)[0];
      if (!elementTag) {
        return;
      }
      const helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
      const helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
      const attributesToRemove = [...helmetAttributes];
      const attributeKeys = Object.keys(attributes);
      for (const attribute of attributeKeys) {
        const value = attributes[attribute] || "";
        if (elementTag.getAttribute(attribute) !== value) {
          elementTag.setAttribute(attribute, value);
        }
        if (helmetAttributes.indexOf(attribute) === -1) {
          helmetAttributes.push(attribute);
        }
        const indexToSave = attributesToRemove.indexOf(attribute);
        if (indexToSave !== -1) {
          attributesToRemove.splice(indexToSave, 1);
        }
      }
      for (let i = attributesToRemove.length - 1; i >= 0; i -= 1) {
        elementTag.removeAttribute(attributesToRemove[i]);
      }
      if (helmetAttributes.length === attributesToRemove.length) {
        elementTag.removeAttribute(HELMET_ATTRIBUTE);
      } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
        elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
      }
    };
    updateTitle = (title, attributes) => {
      if (typeof title !== "undefined" && document.title !== title) {
        document.title = flattenArray(title);
      }
      updateAttributes("title", attributes);
    };
    commitTagChanges = (newState, cb) => {
      const {
        baseTag,
        bodyAttributes,
        htmlAttributes,
        linkTags,
        metaTags,
        noscriptTags,
        onChangeClientState,
        scriptTags,
        styleTags,
        title,
        titleAttributes
      } = newState;
      updateAttributes("body", bodyAttributes);
      updateAttributes("html", htmlAttributes);
      updateTitle(title, titleAttributes);
      const tagUpdates = {
        baseTag: updateTags("base", baseTag),
        linkTags: updateTags("link", linkTags),
        metaTags: updateTags("meta", metaTags),
        noscriptTags: updateTags("noscript", noscriptTags),
        scriptTags: updateTags("script", scriptTags),
        styleTags: updateTags("style", styleTags)
      };
      const addedTags = {};
      const removedTags = {};
      Object.keys(tagUpdates).forEach((tagType) => {
        const { newTags, oldTags } = tagUpdates[tagType];
        if (newTags.length) {
          addedTags[tagType] = newTags;
        }
        if (oldTags.length) {
          removedTags[tagType] = tagUpdates[tagType].oldTags;
        }
      });
      if (cb) {
        cb();
      }
      onChangeClientState(newState, addedTags, removedTags);
    };
    _helmetCallback = null;
    handleStateChangeOnClient = (newState) => {
      if (_helmetCallback) {
        cancelAnimationFrame(_helmetCallback);
      }
      if (newState.defer) {
        _helmetCallback = requestAnimationFrame(() => {
          commitTagChanges(newState, () => {
            _helmetCallback = null;
          });
        });
      } else {
        commitTagChanges(newState);
        _helmetCallback = null;
      }
    };
    client_default = handleStateChangeOnClient;
    HelmetDispatcher = class extends import_react4.Component {
      constructor() {
        super(...arguments);
        __publicField(this, "rendered", false);
      }
      shouldComponentUpdate(nextProps) {
        return !(0, import_shallowequal.default)(nextProps, this.props);
      }
      componentDidUpdate() {
        this.emitChange();
      }
      componentWillUnmount() {
        const { helmetInstances } = this.props.context;
        helmetInstances.remove(this);
        this.emitChange();
      }
      emitChange() {
        const { helmetInstances, setHelmet } = this.props.context;
        let serverState = null;
        const state = reducePropsToState(
          helmetInstances.get().map((instance) => {
            const props = { ...instance.props };
            delete props.context;
            return props;
          })
        );
        if (HelmetProvider.canUseDOM) {
          client_default(state);
        } else if (server_default) {
          serverState = server_default(state);
        }
        setHelmet(serverState);
      }
      // componentWillMount will be deprecated
      // for SSR, initialize on first render
      // constructor is also unsafe in StrictMode
      init() {
        if (this.rendered) {
          return;
        }
        this.rendered = true;
        const { helmetInstances } = this.props.context;
        helmetInstances.add(this);
        this.emitChange();
      }
      render() {
        this.init();
        return null;
      }
    };
    Helmet = (_a2 = class extends import_react.Component {
      shouldComponentUpdate(nextProps) {
        return !(0, import_react_fast_compare.default)(without(this.props, "helmetData"), without(nextProps, "helmetData"));
      }
      mapNestedChildrenToProps(child, nestedChildren) {
        if (!nestedChildren) {
          return null;
        }
        switch (child.type) {
          case "script":
          case "noscript":
            return {
              innerHTML: nestedChildren
            };
          case "style":
            return {
              cssText: nestedChildren
            };
          default:
            throw new Error(
              `<${child.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`
            );
        }
      }
      flattenArrayTypeChildren(child, arrayTypeChildren, newChildProps, nestedChildren) {
        return {
          ...arrayTypeChildren,
          [child.type]: [
            ...arrayTypeChildren[child.type] || [],
            {
              ...newChildProps,
              ...this.mapNestedChildrenToProps(child, nestedChildren)
            }
          ]
        };
      }
      mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren) {
        switch (child.type) {
          case "title":
            return {
              ...newProps,
              [child.type]: nestedChildren,
              titleAttributes: { ...newChildProps }
            };
          case "body":
            return {
              ...newProps,
              bodyAttributes: { ...newChildProps }
            };
          case "html":
            return {
              ...newProps,
              htmlAttributes: { ...newChildProps }
            };
          default:
            return {
              ...newProps,
              [child.type]: { ...newChildProps }
            };
        }
      }
      mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
        let newFlattenedProps = { ...newProps };
        Object.keys(arrayTypeChildren).forEach((arrayChildName) => {
          newFlattenedProps = {
            ...newFlattenedProps,
            [arrayChildName]: arrayTypeChildren[arrayChildName]
          };
        });
        return newFlattenedProps;
      }
      warnOnInvalidChildren(child, nestedChildren) {
        (0, import_invariant.default)(
          VALID_TAG_NAMES.some((name) => child.type === name),
          typeof child.type === "function" ? `You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.` : `Only elements types ${VALID_TAG_NAMES.join(
            ", "
          )} are allowed. Helmet does not support rendering <${child.type}> elements. Refer to our API for more information.`
        );
        (0, import_invariant.default)(
          !nestedChildren || typeof nestedChildren === "string" || Array.isArray(nestedChildren) && !nestedChildren.some((nestedChild) => typeof nestedChild !== "string"),
          `Helmet expects a string as a child of <${child.type}>. Did you forget to wrap your children in braces? ( <${child.type}>{\`\`}</${child.type}> ) Refer to our API for more information.`
        );
        return true;
      }
      mapChildrenToProps(children, newProps) {
        let arrayTypeChildren = {};
        import_react.default.Children.forEach(children, (child) => {
          if (!child || !child.props) {
            return;
          }
          const { children: nestedChildren, ...childProps } = child.props;
          const newChildProps = Object.keys(childProps).reduce((obj, key) => {
            obj[HTML_TAG_MAP[key] || key] = childProps[key];
            return obj;
          }, {});
          let { type } = child;
          if (typeof type === "symbol") {
            type = type.toString();
          } else {
            this.warnOnInvalidChildren(child, nestedChildren);
          }
          switch (type) {
            case "Symbol(react.fragment)":
              newProps = this.mapChildrenToProps(nestedChildren, newProps);
              break;
            case "link":
            case "meta":
            case "noscript":
            case "script":
            case "style":
              arrayTypeChildren = this.flattenArrayTypeChildren(
                child,
                arrayTypeChildren,
                newChildProps,
                nestedChildren
              );
              break;
            default:
              newProps = this.mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren);
              break;
          }
        });
        return this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
      }
      render() {
        const { children, ...props } = this.props;
        let newProps = { ...props };
        let { helmetData } = props;
        if (children) {
          newProps = this.mapChildrenToProps(children, newProps);
        }
        if (helmetData && !(helmetData instanceof HelmetData)) {
          const data = helmetData;
          helmetData = new HelmetData(data.context, true);
          delete newProps.helmetData;
        }
        return helmetData ? import_react.default.createElement(HelmetDispatcher, { ...newProps, context: helmetData.value }) : import_react.default.createElement(Context.Consumer, null, (context) => import_react.default.createElement(HelmetDispatcher, { ...newProps, context }));
      }
    }, __publicField(_a2, "defaultProps", {
      defer: true,
      encodeSpecialCharacters: true,
      prioritizeSeoTags: false
    }), _a2);
  }
});

// ../node_modules/@redwoodjs/web/dist/components/RedwoodProvider.js
var require_RedwoodProvider = __commonJS({
  "../node_modules/@redwoodjs/web/dist/components/RedwoodProvider.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property();
    var _interopRequireDefault = require_interopRequireDefault().default;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RedwoodProvider = void 0;
    var _globalThis2 = _interopRequireDefault(require_global_this());
    var _reactHelmetAsync = (init_index_esm(), __toCommonJS(index_esm_exports));
    var _jsxRuntime = require_jsx_runtime();
    var RedwoodProvider = (_ref) => {
      let {
        children,
        titleTemplate
      } = _ref;
      const appTitle = _globalThis2.default.__REDWOOD__APP_TITLE;
      const template = () => {
        if (titleTemplate) {
          let template2 = titleTemplate.replace(/%AppTitle/g, appTitle);
          template2 = template2.replace(/%PageTitle/g, "%s");
          return template2;
        }
        return "";
      };
      return (0, _jsxRuntime.jsxs)(_reactHelmetAsync.HelmetProvider, {
        context: _globalThis2.default.__REDWOOD__HELMET_CONTEXT,
        children: [(0, _jsxRuntime.jsx)(_reactHelmetAsync.Helmet, {
          titleTemplate: template(),
          defaultTitle: appTitle,
          children: (0, _jsxRuntime.jsx)("title", {
            children: appTitle
          })
        }), children]
      });
    };
    exports.RedwoodProvider = RedwoodProvider;
  }
});

// ../node_modules/@redwoodjs/web/dist/components/MetaTags.js
var require_MetaTags = __commonJS({
  "../node_modules/@redwoodjs/web/dist/components/MetaTags.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property();
    var _interopRequireDefault = require_interopRequireDefault().default;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MetaTags = void 0;
    var _isArray = _interopRequireDefault(require_is_array2());
    var _reactHelmetAsync = (init_index_esm(), __toCommonJS(index_esm_exports));
    var _jsxRuntime = require_jsx_runtime();
    var MetaTags = (props) => {
      const {
        tag = "og:image",
        ogType = "website",
        ogContentUrl,
        robots,
        contentType,
        ogWidth,
        ogHeight,
        ogUrl,
        title,
        locale,
        description,
        author,
        children
      } = props;
      return (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
        children: [title && (0, _jsxRuntime.jsxs)(_reactHelmetAsync.Helmet, {
          children: [(0, _jsxRuntime.jsx)("title", {
            children: title
          }), (0, _jsxRuntime.jsx)("meta", {
            property: "og:title",
            content: title
          }, "title"), (0, _jsxRuntime.jsx)("meta", {
            property: "twitter:title",
            content: title
          })]
        }), description && (0, _jsxRuntime.jsxs)(_reactHelmetAsync.Helmet, {
          children: [(0, _jsxRuntime.jsx)("meta", {
            name: "description",
            content: description
          }), (0, _jsxRuntime.jsx)("meta", {
            name: "twitter:description",
            content: description
          }), (0, _jsxRuntime.jsx)("meta", {
            property: "og:description",
            content: description
          })]
        }), author && (0, _jsxRuntime.jsxs)(_reactHelmetAsync.Helmet, {
          children: [(0, _jsxRuntime.jsx)("meta", {
            name: "author",
            content: author
          }), (0, _jsxRuntime.jsx)("meta", {
            name: "twitter:site",
            content: author
          }), (0, _jsxRuntime.jsx)("meta", {
            name: "twitter:creator",
            content: author
          })]
        }), ogUrl && (0, _jsxRuntime.jsx)(_reactHelmetAsync.Helmet, {
          children: (0, _jsxRuntime.jsx)("meta", {
            property: "og:url",
            content: ogUrl
          })
        }), locale && (0, _jsxRuntime.jsxs)(_reactHelmetAsync.Helmet, {
          children: [(0, _jsxRuntime.jsx)("html", {
            lang: locale
          }), (0, _jsxRuntime.jsx)("meta", {
            property: "og:locale",
            content: locale
          })]
        }), (0, _jsxRuntime.jsx)(_reactHelmetAsync.Helmet, {
          children: (0, _jsxRuntime.jsx)("meta", {
            property: "og:type",
            content: ogType
          })
        }), ogContentUrl && (0, _jsxRuntime.jsx)(_reactHelmetAsync.Helmet, {
          children: (0, _jsxRuntime.jsx)("meta", {
            property: tag,
            content: ogContentUrl
          })
        }), contentType && (0, _jsxRuntime.jsx)(_reactHelmetAsync.Helmet, {
          children: (0, _jsxRuntime.jsx)("meta", {
            property: `${tag}:type`,
            content: contentType
          })
        }), tag === "og:image" && (0, _jsxRuntime.jsxs)(_reactHelmetAsync.Helmet, {
          children: [ogWidth && (0, _jsxRuntime.jsx)("meta", {
            property: "image:width",
            content: ogWidth
          }), ogHeight && (0, _jsxRuntime.jsx)("meta", {
            property: "image:height",
            content: ogHeight
          }), (0, _jsxRuntime.jsx)("meta", {
            property: "twitter:card",
            content: "summary_large_image"
          }), (0, _jsxRuntime.jsx)("meta", {
            property: "twitter:image",
            content: ogContentUrl
          })]
        }), robots && (0, _jsxRuntime.jsx)(_reactHelmetAsync.Helmet, {
          children: (0, _jsxRuntime.jsx)("meta", {
            name: "robots",
            content: (0, _isArray.default)(robots) ? robots.join(", ") : robots
          })
        }), children]
      });
    };
    exports.MetaTags = MetaTags;
  }
});

// ../node_modules/core-js-pure/modules/es.array.reverse.js
var require_es_array_reverse = __commonJS({
  "../node_modules/core-js-pure/modules/es.array.reverse.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var isArray = require_is_array();
    var nativeReverse = uncurryThis([].reverse);
    var test = [1, 2];
    $({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
      reverse: function reverse() {
        if (isArray(this))
          this.length = this.length;
        return nativeReverse(this);
      }
    });
  }
});

// ../node_modules/core-js-pure/es/array/virtual/reverse.js
var require_reverse = __commonJS({
  "../node_modules/core-js-pure/es/array/virtual/reverse.js"(exports, module) {
    "use strict";
    require_es_array_reverse();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "reverse");
  }
});

// ../node_modules/core-js-pure/es/instance/reverse.js
var require_reverse2 = __commonJS({
  "../node_modules/core-js-pure/es/instance/reverse.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_reverse();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.reverse;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.reverse ? method : own;
    };
  }
});

// ../node_modules/core-js-pure/stable/instance/reverse.js
var require_reverse3 = __commonJS({
  "../node_modules/core-js-pure/stable/instance/reverse.js"(exports, module) {
    "use strict";
    var parent = require_reverse2();
    module.exports = parent;
  }
});

// ../node_modules/core-js-pure/actual/instance/reverse.js
var require_reverse4 = __commonJS({
  "../node_modules/core-js-pure/actual/instance/reverse.js"(exports, module) {
    "use strict";
    var parent = require_reverse3();
    module.exports = parent;
  }
});

// ../node_modules/core-js-pure/full/instance/reverse.js
var require_reverse5 = __commonJS({
  "../node_modules/core-js-pure/full/instance/reverse.js"(exports, module) {
    "use strict";
    var parent = require_reverse4();
    module.exports = parent;
  }
});

// ../node_modules/core-js-pure/features/instance/reverse.js
var require_reverse6 = __commonJS({
  "../node_modules/core-js-pure/features/instance/reverse.js"(exports, module) {
    "use strict";
    module.exports = require_reverse5();
  }
});

// ../node_modules/@babel/runtime-corejs3/core-js/instance/reverse.js
var require_reverse7 = __commonJS({
  "../node_modules/@babel/runtime-corejs3/core-js/instance/reverse.js"(exports, module) {
    module.exports = require_reverse6();
  }
});

// ../node_modules/core-js-pure/modules/es.array.flat.js
var require_es_array_flat = __commonJS({
  "../node_modules/core-js-pure/modules/es.array.flat.js"() {
    "use strict";
    var $ = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var arraySpeciesCreate = require_array_species_create();
    $({ target: "Array", proto: true }, {
      flat: function flat() {
        var depthArg = arguments.length ? arguments[0] : void 0;
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));
        return A;
      }
    });
  }
});

// ../node_modules/core-js-pure/modules/es.array.unscopables.flat.js
var require_es_array_unscopables_flat = __commonJS({
  "../node_modules/core-js-pure/modules/es.array.unscopables.flat.js"() {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    addToUnscopables("flat");
  }
});

// ../node_modules/core-js-pure/es/array/virtual/flat.js
var require_flat = __commonJS({
  "../node_modules/core-js-pure/es/array/virtual/flat.js"(exports, module) {
    "use strict";
    require_es_array_flat();
    require_es_array_unscopables_flat();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "flat");
  }
});

// ../node_modules/core-js-pure/es/instance/flat.js
var require_flat2 = __commonJS({
  "../node_modules/core-js-pure/es/instance/flat.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_flat();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.flat;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.flat ? method : own;
    };
  }
});

// ../node_modules/core-js-pure/stable/instance/flat.js
var require_flat3 = __commonJS({
  "../node_modules/core-js-pure/stable/instance/flat.js"(exports, module) {
    "use strict";
    var parent = require_flat2();
    module.exports = parent;
  }
});

// ../node_modules/core-js-pure/actual/instance/flat.js
var require_flat4 = __commonJS({
  "../node_modules/core-js-pure/actual/instance/flat.js"(exports, module) {
    "use strict";
    var parent = require_flat3();
    module.exports = parent;
  }
});

// ../node_modules/core-js-pure/full/instance/flat.js
var require_flat5 = __commonJS({
  "../node_modules/core-js-pure/full/instance/flat.js"(exports, module) {
    "use strict";
    var parent = require_flat4();
    module.exports = parent;
  }
});

// ../node_modules/core-js-pure/features/instance/flat.js
var require_flat6 = __commonJS({
  "../node_modules/core-js-pure/features/instance/flat.js"(exports, module) {
    "use strict";
    module.exports = require_flat5();
  }
});

// ../node_modules/@babel/runtime-corejs3/core-js/instance/flat.js
var require_flat7 = __commonJS({
  "../node_modules/@babel/runtime-corejs3/core-js/instance/flat.js"(exports, module) {
    module.exports = require_flat6();
  }
});

// ../node_modules/@redwoodjs/web/dist/components/Metadata.js
var require_Metadata = __commonJS({
  "../node_modules/@redwoodjs/web/dist/components/Metadata.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property();
    var _interopRequireDefault = require_interopRequireDefault().default;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Metadata = void 0;
    var _isArray = _interopRequireDefault(require_is_array2());
    var _flatMap = _interopRequireDefault(require_flat_map());
    var _filter = _interopRequireDefault(require_filter());
    var _entries = _interopRequireDefault(require_entries());
    var _includes = _interopRequireDefault(require_includes());
    var _map = _interopRequireDefault(require_map());
    var _reverse = _interopRequireDefault(require_reverse7());
    var _flat = _interopRequireDefault(require_flat7());
    var _react = _interopRequireDefault(require_react());
    var _reactHelmetAsync = (init_index_esm(), __toCommonJS(index_esm_exports));
    var _jsxRuntime = require_jsx_runtime();
    var EXCLUDE_PROPS = ["charSet"];
    var propToMetaTag = (parentKey, parentValue, options) => {
      if ((0, _isArray.default)(parentValue)) {
        return (0, _flatMap.default)(parentValue).call(parentValue, (value) => {
          return propToMetaTag(parentKey, value, options);
        });
      } else if (typeof parentValue === "object") {
        var _context, _context2;
        return (0, _flatMap.default)(_context = (0, _filter.default)(_context2 = (0, _entries.default)(parentValue)).call(_context2, (_ref) => {
          let [_, v] = _ref;
          return v !== null;
        })).call(_context, (_ref2) => {
          let [key, value] = _ref2;
          return propToMetaTag(`${parentKey}:${key}`, value, {
            attr: "property"
          });
        });
      } else {
        const attributes = {
          [options["attr"]]: parentKey,
          content: parentValue
        };
        return (0, _jsxRuntime.jsx)("meta", {
          ...attributes
        });
      }
    };
    var Metadata = (props) => {
      var _context3, _context4, _context5;
      const {
        children,
        ...metaProps
      } = props;
      const Head = _reactHelmetAsync.Helmet;
      const tags = (0, _filter.default)(_context3 = (0, _flatMap.default)(_context4 = (0, _filter.default)(_context5 = (0, _entries.default)(metaProps)).call(_context5, (_ref3) => {
        let [key, value] = _ref3;
        return !(0, _includes.default)(EXCLUDE_PROPS).call(EXCLUDE_PROPS, key) && value !== null && (key !== "og" || value !== true);
      })).call(_context4, (_ref4) => {
        let [key, value] = _ref4;
        return propToMetaTag(key, value, {
          attr: "name"
        });
      })).call(_context3, (tag) => !!tag);
      if (metaProps.title) {
        var _context6, _context7, _context8;
        ;
        (0, _map.default)(_context6 = (0, _reverse.default)(_context7 = (0, _flat.default)(_context8 = [metaProps.title]).call(_context8)).call(_context7)).call(_context6, (title) => {
          tags.unshift((0, _jsxRuntime.jsx)("title", {
            children: title
          }));
        });
      }
      if (metaProps.charSet) {
        tags.push((0, _jsxRuntime.jsx)("meta", {
          charSet: metaProps.charSet
        }));
      }
      if (metaProps.og) {
        if (metaProps.title && !metaProps.og.title && metaProps.og.title !== null) {
          tags.push((0, _jsxRuntime.jsx)("meta", {
            property: "og:title",
            content: metaProps.title
          }));
        }
        if (metaProps.description && !metaProps.og.description && metaProps.og.description !== null) {
          tags.push((0, _jsxRuntime.jsx)("meta", {
            property: "og:description",
            content: metaProps.description
          }));
        }
        if (!metaProps.og.type && metaProps.og.type !== null) {
          tags.push((0, _jsxRuntime.jsx)("meta", {
            property: "og:type",
            content: "website"
          }));
        }
      }
      return (0, _jsxRuntime.jsxs)(Head, {
        children: [(0, _map.default)(tags).call(tags, (tag, i) => _react.default.cloneElement(tag, {
          key: i
        })), children]
      });
    };
    exports.Metadata = Metadata;
  }
});

// ../node_modules/@redwoodjs/web/dist/index.js
var require_dist = __commonJS({
  "../node_modules/@redwoodjs/web/dist/index.js"(exports) {
    var _context;
    var _context2;
    var _context3;
    var _context4;
    var _context5;
    var _Object$defineProperty = require_define_property();
    var _forEachInstanceProperty = require_for_each();
    var _Object$keys = require_keys();
    var _interopRequireDefault = require_interopRequireDefault().default;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      FatalErrorBoundary: true,
      FetchConfigProvider: true,
      useFetchConfig: true,
      GraphQLHooksProvider: true,
      useQuery: true,
      useMutation: true,
      useSubscription: true,
      createCell: true,
      CellProps: true,
      CellFailureProps: true,
      CellLoadingProps: true,
      CellSuccessProps: true,
      CellSuccessData: true,
      Head: true,
      Helmet: true
    };
    _Object$defineProperty(exports, "CellFailureProps", {
      enumerable: true,
      get: function() {
        return _createCell.CellFailureProps;
      }
    });
    _Object$defineProperty(exports, "CellLoadingProps", {
      enumerable: true,
      get: function() {
        return _createCell.CellLoadingProps;
      }
    });
    _Object$defineProperty(exports, "CellProps", {
      enumerable: true,
      get: function() {
        return _createCell.CellProps;
      }
    });
    _Object$defineProperty(exports, "CellSuccessData", {
      enumerable: true,
      get: function() {
        return _createCell.CellSuccessData;
      }
    });
    _Object$defineProperty(exports, "CellSuccessProps", {
      enumerable: true,
      get: function() {
        return _createCell.CellSuccessProps;
      }
    });
    _Object$defineProperty(exports, "FatalErrorBoundary", {
      enumerable: true,
      get: function() {
        return _FatalErrorBoundary.default;
      }
    });
    _Object$defineProperty(exports, "FetchConfigProvider", {
      enumerable: true,
      get: function() {
        return _FetchConfigProvider.FetchConfigProvider;
      }
    });
    _Object$defineProperty(exports, "GraphQLHooksProvider", {
      enumerable: true,
      get: function() {
        return _GraphQLHooksProvider.GraphQLHooksProvider;
      }
    });
    _Object$defineProperty(exports, "Head", {
      enumerable: true,
      get: function() {
        return _reactHelmetAsync.Helmet;
      }
    });
    _Object$defineProperty(exports, "Helmet", {
      enumerable: true,
      get: function() {
        return _reactHelmetAsync.Helmet;
      }
    });
    _Object$defineProperty(exports, "createCell", {
      enumerable: true,
      get: function() {
        return _createCell.createCell;
      }
    });
    _Object$defineProperty(exports, "useFetchConfig", {
      enumerable: true,
      get: function() {
        return _FetchConfigProvider.useFetchConfig;
      }
    });
    _Object$defineProperty(exports, "useMutation", {
      enumerable: true,
      get: function() {
        return _GraphQLHooksProvider.useMutation;
      }
    });
    _Object$defineProperty(exports, "useQuery", {
      enumerable: true,
      get: function() {
        return _GraphQLHooksProvider.useQuery;
      }
    });
    _Object$defineProperty(exports, "useSubscription", {
      enumerable: true,
      get: function() {
        return _GraphQLHooksProvider.useSubscription;
      }
    });
    require_global_web_auto_imports();
    require_config();
    require_assetImports();
    var _FatalErrorBoundary = _interopRequireDefault(require_FatalErrorBoundary());
    var _FetchConfigProvider = require_FetchConfigProvider();
    var _GraphQLHooksProvider = require_GraphQLHooksProvider();
    var _CellCacheContext = require_CellCacheContext();
    _forEachInstanceProperty(_context = _Object$keys(_CellCacheContext)).call(_context, function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _CellCacheContext[key])
        return;
      _Object$defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _CellCacheContext[key];
        }
      });
    });
    var _createCell = require_createCell();
    var _graphql = require_graphql();
    _forEachInstanceProperty(_context2 = _Object$keys(_graphql)).call(_context2, function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _graphql[key])
        return;
      _Object$defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _graphql[key];
        }
      });
    });
    var _RedwoodProvider = require_RedwoodProvider();
    _forEachInstanceProperty(_context3 = _Object$keys(_RedwoodProvider)).call(_context3, function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _RedwoodProvider[key])
        return;
      _Object$defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _RedwoodProvider[key];
        }
      });
    });
    var _MetaTags = require_MetaTags();
    _forEachInstanceProperty(_context4 = _Object$keys(_MetaTags)).call(_context4, function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _MetaTags[key])
        return;
      _Object$defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _MetaTags[key];
        }
      });
    });
    var _Metadata = require_Metadata();
    _forEachInstanceProperty(_context5 = _Object$keys(_Metadata)).call(_context5, function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _Metadata[key])
        return;
      _Object$defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _Metadata[key];
        }
      });
    });
    var _reactHelmetAsync = (init_index_esm(), __toCommonJS(index_esm_exports));
  }
});
export default require_dist();
//# sourceMappingURL=@redwoodjs_web.js.map
