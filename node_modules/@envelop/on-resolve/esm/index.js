import { defaultFieldResolver, isIntrospectionType, isObjectType, } from 'graphql';
/**
 * Wraps the provided schema by hooking into the resolvers of every field.
 *
 * Use the `onResolve` argument to manipulate the resolver and its results/errors.
 */
export function useOnResolve(onResolve, opts = { skipIntrospection: true }) {
    const hasWrappedResolveSymbol = Symbol('hasWrappedResolve');
    return {
        onSchemaChange({ schema: _schema }) {
            const schema = _schema;
            if (!schema)
                return; // nothing to do if schema is missing
            for (const type of Object.values(schema.getTypeMap())) {
                if ((!opts.skipIntrospection || !isIntrospectionType(type)) && isObjectType(type)) {
                    for (const field of Object.values(type.getFields())) {
                        if (field[hasWrappedResolveSymbol])
                            continue;
                        let resolver = (field.resolve || defaultFieldResolver);
                        field.resolve = async (root, args, context, info) => {
                            const afterResolve = await onResolve({
                                root,
                                args,
                                context,
                                info,
                                resolver,
                                replaceResolver: newResolver => {
                                    resolver = newResolver;
                                },
                            });
                            let result;
                            try {
                                result = await resolver(root, args, context, info);
                            }
                            catch (err) {
                                result = err;
                            }
                            if (typeof afterResolve === 'function') {
                                await afterResolve({
                                    result,
                                    setResult: newResult => {
                                        result = newResult;
                                    },
                                });
                            }
                            if (result instanceof Error) {
                                throw result;
                            }
                            return result;
                        };
                        field[hasWrappedResolveSymbol] = true;
                    }
                }
            }
        },
    };
}
