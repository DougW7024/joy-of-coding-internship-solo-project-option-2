var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "@redwoodjs/cli-helpers",
      version: "7.7.2",
      repository: {
        type: "git",
        url: "git+https://github.com/redwoodjs/redwood.git",
        directory: "packages/cli-helpers"
      },
      license: "MIT",
      type: "module",
      exports: {
        types: "./dist/index.d.ts",
        import: "./dist/index.mjs",
        default: "./dist/index.cjs"
      },
      types: "./dist/index.d.ts",
      files: [
        "dist"
      ],
      scripts: {
        build: "tsx ./build.ts && yarn build:types",
        "build:pack": "yarn pack -o redwoodjs-cli-helpers.tgz",
        "build:types": "tsc --build --verbose tsconfig.build.json",
        "build:watch": 'nodemon --watch src --ext "js,jsx,ts,tsx" --ignore dist --exec "yarn build"',
        prepublishOnly: "NODE_ENV=production yarn build",
        test: "vitest run",
        "test:watch": "vitest watch"
      },
      dependencies: {
        "@babel/core": "^7.22.20",
        "@opentelemetry/api": "1.8.0",
        "@redwoodjs/project-config": "7.7.2",
        "@redwoodjs/telemetry": "7.7.2",
        chalk: "4.1.2",
        dotenv: "16.4.5",
        execa: "5.1.1",
        listr2: "6.6.1",
        lodash: "4.17.21",
        pascalcase: "1.0.0",
        prettier: "2.8.8",
        prompts: "2.4.2",
        "smol-toml": "1.2.1",
        "terminal-link": "2.1.1"
      },
      devDependencies: {
        "@types/lodash": "4.17.5",
        "@types/pascalcase": "1.0.3",
        "@types/yargs": "17.0.32",
        tsx: "4.15.2",
        typescript: "5.4.5",
        vitest: "1.6.0"
      },
      gitHead: "27e1669528adf05f325ec862c23f3b7da9abdc17"
    };
  }
});

// src/lib/index.ts
import fs from "fs";
import path from "path";
import * as babel from "@babel/core";
import { Listr } from "listr2";
import { format } from "prettier";

// src/lib/colors.ts
import chalk from "chalk";
var colors = {
  error: chalk.bold.red,
  warning: chalk.keyword("orange"),
  green: chalk.green,
  info: chalk.grey,
  bold: chalk.bold,
  underline: chalk.underline
};

// src/lib/paths.ts
import { getPaths as _getPaths } from "@redwoodjs/project-config";
function isErrorWithMessage(e) {
  return !!e.message;
}
function getPaths() {
  try {
    return _getPaths();
  } catch (e) {
    if (isErrorWithMessage(e)) {
      console.error(colors.error(e.message));
    }
    process.exit(1);
  }
}

// src/lib/index.ts
var transformTSToJS = (filename, content) => {
  if (!content) {
    return content;
  }
  const babelFileResult = babel.transform(content, {
    filename,
    // If you ran `yarn rw generate` in `./web` transformSync would import the `.babelrc.js` file,
    // in `./web`? despite us setting `configFile: false`.
    cwd: process.env.NODE_ENV === "test" ? void 0 : getPaths().base,
    configFile: false,
    plugins: [
      [
        "@babel/plugin-transform-typescript",
        {
          isTSX: true,
          allExtensions: true
        }
      ]
    ],
    retainLines: true
  });
  if (!babelFileResult?.code) {
    console.error(colors.error(`Could not transform ${filename} to JS`));
    process.exit(1);
  }
  return prettify(filename.replace(/\.ts(x)?$/, ".js$1"), babelFileResult.code);
};
var getPrettierOptions = async () => {
  try {
    const { default: options } = await import(`file://${path.join(getPaths().base, "prettier.config.js")}`);
    if (options.tailwindConfig?.startsWith(".")) {
      options.tailwindConfig = path.join(
        process.env.RWJS_CWD ?? process.cwd(),
        options.tailwindConfig
      );
    }
    return options;
  } catch (e) {
    return void 0;
  }
};
var prettify = async (templateFilename, renderedTemplate) => {
  const parser = {
    ".css": "css",
    ".js": "babel",
    ".ts": "babel-ts",
    ".tsx": "babel-ts"
  }[path.extname(templateFilename.replace(".template", ""))];
  if (typeof parser === "undefined") {
    return renderedTemplate;
  }
  const prettierOptions = await getPrettierOptions();
  return format(renderedTemplate, {
    ...prettierOptions,
    parser
  });
};
var writeFile = (target, contents, { existingFiles = "FAIL" } = {}, task = {}) => {
  const { base } = getPaths();
  task.title = `Writing \`./${path.relative(base, target)}\``;
  const exists = fs.existsSync(target);
  if (exists && existingFiles === "FAIL") {
    throw new Error(`${target} already exists.`);
  }
  if (exists && existingFiles === "SKIP") {
    task.skip(`Skipping update of \`./${path.relative(base, target)}\``);
    return;
  }
  const filename = path.basename(target);
  const targetDir = target.replace(filename, "");
  fs.mkdirSync(targetDir, { recursive: true });
  fs.writeFileSync(target, contents);
  task.title = `Successfully wrote file \`./${path.relative(base, target)}\``;
};
var writeFilesTask = (files, options) => {
  const { base } = getPaths();
  return new Listr(
    Object.keys(files).map((file) => {
      const contents = files[file];
      return {
        title: `...waiting to write file \`./${path.relative(base, file)}\`...`,
        task: (_ctx, task) => {
          return writeFile(file, contents, options, task);
        }
      };
    })
  );
};

// src/lib/project.ts
import * as fs2 from "node:fs";
import * as path2 from "node:path";
import dotenv from "dotenv";
import * as toml from "smol-toml";
import {
  findUp,
  getConfigPath,
  getConfig,
  resolveFile
} from "@redwoodjs/project-config";
var getGraphqlPath = () => {
  return resolveFile(path2.join(getPaths().api.functions, "graphql"));
};
var graphFunctionDoesExist = () => {
  const graphqlPath = getGraphqlPath();
  return graphqlPath && fs2.existsSync(graphqlPath);
};
var isTypeScriptProject = () => {
  const paths = getPaths();
  return fs2.existsSync(path2.join(paths.web.base, "tsconfig.json")) || fs2.existsSync(path2.join(paths.api.base, "tsconfig.json"));
};
var getInstalledRedwoodVersion = () => {
  try {
    const packageJson = require_package();
    return packageJson.version;
  } catch (e) {
    console.error(colors.error("Could not find installed redwood version"));
    process.exit(1);
  }
};
var updateTomlConfig = (packageName) => {
  const redwoodTomlPath = getConfigPath();
  const originalTomlContent = fs2.readFileSync(redwoodTomlPath, "utf-8");
  let tomlToAppend = {};
  const config = getConfig(redwoodTomlPath);
  const cliSection = config.experimental?.cli;
  if (!cliSection) {
    tomlToAppend = {
      experimental: {
        cli: {
          autoInstall: true,
          plugins: [{ package: packageName, enabled: true }]
        }
      }
    };
  } else if (cliSection.plugins) {
    const packageExists = cliSection.plugins.some(
      (plugin) => plugin.package === packageName
    );
    if (!packageExists) {
      tomlToAppend = {
        experimental: {
          cli: {
            plugins: [{ package: packageName, enabled: true }]
          }
        }
      };
    }
  } else {
    tomlToAppend = {
      experimental: {
        cli: {
          plugins: [{ package: packageName, enabled: true }]
        }
      }
    };
  }
  const newConfig = originalTomlContent + "\n" + (Object.keys(tomlToAppend).length > 0 ? toml.stringify(tomlToAppend) + "\n" : "");
  return fs2.writeFileSync(redwoodTomlPath, newConfig, "utf-8");
};
var updateTomlConfigTask = (packageName) => {
  return {
    title: `Updating redwood.toml to configure ${packageName} ...`,
    task: () => {
      updateTomlConfig(packageName);
    }
  };
};
var addEnvVarTask = (name, value, comment) => {
  return {
    title: `Adding ${name} var to .env...`,
    task: () => {
      addEnvVar(name, value, comment);
    }
  };
};
var addEnvVar = (name, value, comment) => {
  const envPath = path2.join(getPaths().base, ".env");
  let envFile = "";
  const newEnvironmentVariable = [
    comment && `# ${comment}`,
    `${name} = ${value}`,
    ""
  ].flat().join("\n");
  if (fs2.existsSync(envPath)) {
    envFile = fs2.readFileSync(envPath).toString();
    const existingEnvVars = dotenv.parse(envFile);
    if (existingEnvVars[name] && existingEnvVars[name] === value) {
      return envFile;
    }
    if (existingEnvVars[name]) {
      const p = [
        `# Note: The existing environment variable ${name} was not overwritten. Uncomment to use its new value.`,
        comment && `# ${comment}`,
        `# ${name} = ${value}`,
        ""
      ].flat().join("\n");
      envFile += "\n" + p;
    } else {
      envFile += "\n" + newEnvironmentVariable;
    }
  } else {
    envFile = newEnvironmentVariable;
  }
  return fs2.writeFileSync(envPath, envFile);
};
var setRedwoodCWD = (cwd) => {
  cwd ??= process.env.RWJS_CWD;
  if (cwd) {
    if (!fs2.existsSync(path2.join(cwd, "redwood.toml"))) {
      throw new Error(`Couldn't find a "redwood.toml" file in ${cwd}`);
    }
  } else {
    const redwoodTOMLPath = findUp("redwood.toml", process.cwd());
    if (!redwoodTOMLPath) {
      throw new Error(
        `Couldn't find up a "redwood.toml" file from ${process.cwd()}`
      );
    }
    if (redwoodTOMLPath) {
      cwd = path2.dirname(redwoodTOMLPath);
    }
  }
  process.env.RWJS_CWD = cwd;
};
function setTomlSetting(section, setting, value) {
  const redwoodTomlPath = getConfigPath();
  const originalTomlContent = fs2.readFileSync(redwoodTomlPath, "utf-8");
  const redwoodTomlObject = toml.parse(originalTomlContent);
  const sectionValue = redwoodTomlObject[section];
  const existingValue = (
    // I don't like this type cast, but I couldn't come up with a much better
    // solution
    sectionValue?.[setting]
  );
  if (existingValue === value) {
    return;
  }
  let newTomlContent = originalTomlContent.replace(/\n$/, "") + `

[${section}]
  ${setting} = ${value}`;
  const hasExistingSettingSection = !!redwoodTomlObject?.[section];
  if (hasExistingSettingSection) {
    const existingSectionSettings = Object.keys(redwoodTomlObject[section]);
    let inSection = false;
    let indentation = "";
    let insertionIndex = 1;
    let updateExistingValue = false;
    let updateExistingCommentedValue = false;
    const tomlLines = originalTomlContent.split("\n");
    tomlLines.forEach((line, index) => {
      if (line.startsWith(`[${section}]`)) {
        inSection = true;
        insertionIndex = index + 1;
      } else {
        if (/^\s*\[/.test(line)) {
          inSection = false;
        }
        if (inSection && !updateExistingValue) {
          for (const existingSectionSetting of existingSectionSettings) {
            const matches = line.match(
              new RegExp(`^(\\s*)${existingSectionSetting}\\s*=`, "i")
            );
            if (!updateExistingValue && matches) {
              if (!updateExistingCommentedValue) {
                indentation = matches[1];
              }
              if (existingSectionSetting === setting) {
                updateExistingValue = true;
                insertionIndex = index;
                indentation = matches[1];
              }
            }
            if (!updateExistingValue && !updateExistingCommentedValue && /^\s*\w+\s*=/.test(line)) {
              insertionIndex = index + 1;
            }
          }
          if (!updateExistingValue) {
            const matchesComment = line.match(
              new RegExp(`^(\\s*)#(\\s*)${setting}\\s*=`, "i")
            );
            if (matchesComment) {
              const commentIndentation = matchesComment[1].length > matchesComment[2].length ? matchesComment[1] : matchesComment[2];
              if (commentIndentation.length - 1 > indentation.length) {
                indentation = commentIndentation;
              }
              updateExistingCommentedValue = true;
              insertionIndex = index;
            }
          }
        }
      }
    });
    tomlLines.splice(
      insertionIndex,
      updateExistingValue || updateExistingCommentedValue ? 1 : 0,
      `${indentation}${setting} = ${value}`
    );
    newTomlContent = tomlLines.join("\n");
  }
  fs2.writeFileSync(redwoodTomlPath, newTomlContent);
}

// src/lib/version.ts
import fs3 from "fs";
import path3 from "path";
import semver from "semver";
import { getPaths as getPaths2 } from "@redwoodjs/project-config";
function getCorrespondingTag(version, distTags) {
  return Object.entries(distTags).find(([_, v]) => v === version)?.[0];
}
async function getCompatibilityData(packageName, preferredVersionOrTag) {
  const projectPackageJson = JSON.parse(
    fs3.readFileSync(path3.join(getPaths2().base, "package.json"), {
      encoding: "utf8"
    })
  );
  const projectRedwoodVersion = projectPackageJson.devDependencies["@redwoodjs/core"];
  const semverVersion = semver.parse(preferredVersionOrTag);
  const isUsingTag = semverVersion === null;
  const res = await fetch(`https://registry.npmjs.org/${packageName}`);
  const packument = await res.json();
  if (packument.error !== void 0) {
    throw new Error(packument.error);
  }
  if (isUsingTag) {
    if (packument["dist-tags"][preferredVersionOrTag] === void 0) {
      throw new Error(
        `The package '${packageName}' does not have a tag '${preferredVersionOrTag}'`
      );
    }
  } else {
    if (packument.versions[preferredVersionOrTag] === void 0) {
      throw new Error(
        `The package '${packageName}' does not have a version '${preferredVersionOrTag}'`
      );
    }
  }
  const preferredVersion = isUsingTag ? packument["dist-tags"][preferredVersionOrTag] : preferredVersionOrTag;
  const packageRedwoodSpecification = packument.versions[preferredVersion].engines?.redwoodjs;
  if (packageRedwoodSpecification !== void 0 && semver.intersects(projectRedwoodVersion, packageRedwoodSpecification)) {
    const tag = getCorrespondingTag(preferredVersion, packument["dist-tags"]);
    return {
      preferred: {
        tag,
        version: preferredVersion
      },
      compatible: {
        tag,
        version: preferredVersion
      }
    };
  }
  const versions = semver.sort(Object.keys(packument.versions));
  for (let i = versions.length - 1; i >= 0; i--) {
    const redwoodVersionRequired = packument.versions[versions[i]].engines?.redwoodjs;
    if (redwoodVersionRequired === void 0) {
      continue;
    }
    if (semver.intersects(projectRedwoodVersion, redwoodVersionRequired)) {
      return {
        preferred: {
          tag: getCorrespondingTag(preferredVersion, packument["dist-tags"]),
          version: preferredVersion
        },
        compatible: {
          tag: getCorrespondingTag(versions[i], packument["dist-tags"]),
          version: versions[i]
        }
      };
    }
  }
  throw new Error(`No compatible version of '${packageName}' was found`);
}

// src/auth/setupHelpers.ts
import { Listr as Listr2 } from "listr2";
import terminalLink from "terminal-link";
import { errorTelemetry } from "@redwoodjs/telemetry";

// src/lib/installHelpers.ts
import execa from "execa";
var addWebPackages = (webPackages) => ({
  title: "Adding required web packages...",
  task: async () => {
    await execa("yarn", ["add", ...webPackages], { cwd: getPaths().web.base });
  }
});
var addApiPackages = (apiPackages) => ({
  title: "Adding required api packages...",
  task: async () => {
    await execa("yarn", ["add", ...apiPackages], { cwd: getPaths().api.base });
  }
});
var addRootPackages = (packages, devDependency = false) => {
  const addMode = devDependency ? ["add", "-D"] : ["add"];
  return {
    title: "Installing packages...",
    task: async () => {
      await execa("yarn", [...addMode, ...packages], { cwd: getPaths().base });
    }
  };
};
var installPackages = {
  title: "Installing packages...",
  task: async () => {
    await execa("yarn", ["install"], { cwd: getPaths().base });
  }
};

// src/auth/authTasks.ts
import fs5 from "fs";
import path5 from "path";
import { resolveFile as resolveFile2 } from "@redwoodjs/project-config";

// src/auth/authFiles.ts
import fs4 from "fs";
import path4 from "path";
import pascalcase from "pascalcase";
var apiSideFiles = async ({ basedir, webAuthn }) => {
  const apiSrcPath = getPaths().api.src;
  const apiBaseTemplatePath = path4.join(basedir, "templates", "api");
  const templateDirectories = fs4.readdirSync(apiBaseTemplatePath);
  let filesRecord = {};
  for (const dir of templateDirectories) {
    const templateFiles = fs4.readdirSync(path4.join(apiBaseTemplatePath, dir));
    const filePaths = templateFiles.filter((fileName) => {
      const fileNameParts = fileName.split(".");
      return fileNameParts.length <= 3 || fileNameParts.at(-3) !== "webAuthn";
    }).map((fileName) => {
      let outputFileName = fileName.replace(/\.template$/, "");
      if (!isTypeScriptProject()) {
        outputFileName = outputFileName.replace(/\.ts(x?)$/, ".js$1");
      }
      if (!webAuthn) {
        return { templateFileName: fileName, outputFileName };
      }
      const webAuthnFileName = fileName.split(".").reverse().map((part, i) => i === 1 ? "webAuthn." + part : part).reverse().join(".");
      if (templateFiles.includes(webAuthnFileName)) {
        return { templateFileName: webAuthnFileName, outputFileName };
      } else {
        return { templateFileName: fileName, outputFileName };
      }
    }).map((f) => {
      const templateFilePath = path4.join(
        apiBaseTemplatePath,
        dir,
        f.templateFileName
      );
      const outputFilePath = path4.join(apiSrcPath, dir, f.outputFileName);
      return { templateFilePath, outputFilePath };
    });
    for (const paths of filePaths) {
      const content = fs4.readFileSync(paths.templateFilePath, "utf8");
      filesRecord = {
        ...filesRecord,
        [paths.outputFilePath]: isTypeScriptProject() ? content : await transformTSToJS(paths.outputFilePath, content)
      };
    }
  }
  return filesRecord;
};
function generateUniqueFileNames(filesRecord, provider) {
  const newFilesRecord = {};
  Object.keys(filesRecord).forEach((fullPath) => {
    let newFullPath = fullPath;
    let i = 1;
    while (fs4.existsSync(newFullPath)) {
      const nameParts = path4.basename(fullPath).split(".");
      if (nameParts[0] === provider) {
        const newFileName = provider + (i + 1) + "." + nameParts.slice(1).join(".");
        newFullPath = path4.join(path4.dirname(fullPath), newFileName);
      } else {
        const count = i > 1 ? i : "";
        const newFileName = provider + pascalcase(nameParts[0]) + count + "." + nameParts.slice(1).join(".");
        newFullPath = path4.join(path4.dirname(fullPath), newFileName);
      }
      i++;
    }
    newFilesRecord[newFullPath] = filesRecord[fullPath];
  });
  return newFilesRecord;
}

// src/auth/authTasks.ts
var AUTH_PROVIDER_HOOK_IMPORT = `import { AuthProvider, useAuth } from './auth'`;
var AUTH_HOOK_IMPORT = `import { useAuth } from './auth'`;
var getWebAppPath = () => getPaths().web.app;
function addAuthDecoderToCreateGraphQLHandler(content) {
  if (!new RegExp("(?=(^.*?createGraphQLHandler))\\1.*\\bauthDecoder", "s").test(
    content
  )) {
    return content.replace(
      /^(?<indentation>\s*)(loggerConfig:)(.*)$/m,
      `$<indentation>authDecoder,
$<indentation>$2$3`
    );
  }
  return content;
}
function replaceAuthDecoderImport(content, decoderImport) {
  return content.replace(/^import { authDecoder .*} from .+/, decoderImport);
}
function replaceAuthDecoderArg(content) {
  return content.replace(/^(\s+)authDecoder\b.+/m, "$1authDecoder,");
}
var addApiConfig = ({
  replaceExistingImport,
  authDecoderImport
}) => {
  const graphqlPath = getGraphqlPath();
  if (!graphqlPath) {
    throw new Error("Could not find your graphql file path");
  }
  const content = fs5.readFileSync(graphqlPath).toString();
  let newContent = content;
  if (authDecoderImport) {
    if (replaceExistingImport) {
      newContent = replaceAuthDecoderImport(newContent, authDecoderImport);
      newContent = replaceAuthDecoderArg(newContent);
    }
    const didReplace = newContent.includes(authDecoderImport);
    if (!replaceExistingImport || !didReplace) {
      newContent = authDecoderImport + "\n" + newContent;
      newContent = addAuthDecoderToCreateGraphQLHandler(newContent);
    }
  }
  const hasCurrentUserImport = /(^import {.*?getCurrentUser(?!getCurrentUser).*?} from 'src\/lib\/auth')/s.test(
    newContent
  );
  if (!hasCurrentUserImport) {
    newContent = newContent.replace(
      /^(import { db } from 'src\/lib\/db')$/m,
      `import { getCurrentUser } from 'src/lib/auth'
$1`
    );
    newContent = newContent.replace(
      /^(\s*)(loggerConfig:)(.*)$/m,
      `$1getCurrentUser,
$1$2$3`
    );
  }
  if (newContent !== content) {
    fs5.writeFileSync(graphqlPath, newContent);
  }
};
var apiSrcDoesExist = () => {
  return fs5.existsSync(path5.join(getPaths().api.src));
};
var addAuthImportToApp = (content) => {
  const contentLines = content.split("\n");
  const importIndex = contentLines.findLastIndex(
    (line) => /^\s*import (?!.*(?:.css'|.scss'))/.test(line)
  );
  contentLines.splice(importIndex + 1, 0, "", AUTH_PROVIDER_HOOK_IMPORT);
  return contentLines.join("\n");
};
var addAuthImportToRoutes = (content) => {
  const contentLines = content.split("\n");
  const importIndex = contentLines.findLastIndex(
    (line) => /^\s*import (?!.*(?:.css'|.scss'))/.test(line)
  );
  contentLines.splice(importIndex + 1, 0, "", AUTH_HOOK_IMPORT);
  return contentLines.join("\n");
};
var hasAuthProvider = (content) => {
  return /\s*<AuthProvider([\s>]|$)/.test(content);
};
var removeAuthProvider = (content) => {
  let remove = false;
  let end = "";
  let unindent = false;
  return content.split("\n").reduce((acc, line) => {
    let keep = !remove;
    if (hasAuthProvider(line)) {
      remove = true;
      keep = false;
      unindent = true;
      end = line.replace(/^(\s*)<Auth.*/s, "$1") + ">";
    }
    if (hasAuthProvider(line) && line.trimEnd().at(-1) === ">" || line.trimEnd() === end) {
      remove = false;
    }
    if (/\s*<\/AuthProvider>/.test(line)) {
      keep = false;
      unindent = false;
    }
    if (keep) {
      if (unindent) {
        acc.push(line.replace("  ", ""));
      } else {
        acc.push(line);
      }
    }
    return acc;
  }, []).join("\n");
};
var addAuthProviderToApp = (content, setupMode) => {
  if (setupMode === "FORCE" || setupMode === "REPLACE") {
    content = removeAuthProvider(content);
  }
  const match = content.match(
    /(\s+)(<RedwoodProvider.*?>)(.*)(<\/RedwoodProvider>)/s
  );
  if (!match) {
    throw new Error("Could not find <RedwoodProvider> in App.{jsx,tsx}");
  }
  if (/\s+<AuthProvider>/.test(content)) {
    return content;
  }
  const [
    _,
    newlineAndIndent,
    redwoodProviderOpen,
    redwoodProviderChildren,
    redwoodProviderClose
  ] = match;
  const redwoodProviderChildrenLines = redwoodProviderChildren.split("\n").map((line, index) => {
    return `${index === 0 ? "" : "  "}` + line;
  });
  const renderContent = newlineAndIndent + redwoodProviderOpen + newlineAndIndent + `  <AuthProvider>` + redwoodProviderChildrenLines.join("\n") + `</AuthProvider>` + newlineAndIndent + redwoodProviderClose;
  return content.replace(
    /\s+<RedwoodProvider.*?>.*<\/RedwoodProvider>/s,
    renderContent
  );
};
var hasUseAuthHook = (componentName, content) => {
  return new RegExp(
    `<${componentName}.*useAuth={.*?}.*?>.*</${componentName}>`,
    "s"
  ).test(content);
};
var addUseAuthHook = (componentName, content) => {
  return content.replace(
    `<${componentName}`,
    `<${componentName} useAuth={useAuth}`
  );
};
var addConfigToWebApp = () => {
  return {
    title: "Updating web/src/App.{jsx,tsx}",
    task: (ctx, task) => {
      const webAppPath = getWebAppPath();
      if (!fs5.existsSync(webAppPath)) {
        const ext = isTypeScriptProject() ? "tsx" : "jsx";
        throw new Error(`Could not find root App.${ext}`);
      }
      let content = fs5.readFileSync(webAppPath, "utf-8");
      if (!content.includes(AUTH_PROVIDER_HOOK_IMPORT)) {
        content = addAuthImportToApp(content);
      }
      if (ctx.setupMode === "REPLACE" || ctx.setupMode === "FORCE") {
        content = content.replace(
          "import { AuthProvider } from '@redwoodjs/auth'\n",
          ""
        );
      }
      content = addAuthProviderToApp(content, ctx.setupMode);
      if (/\s*<RedwoodApolloProvider/.test(content)) {
        if (!hasUseAuthHook("RedwoodApolloProvider", content)) {
          content = addUseAuthHook("RedwoodApolloProvider", content);
        }
      } else {
        task.output = colors.warning(
          "Could not find <RedwoodApolloProvider>.\nIf you are using a custom GraphQL Client you will have to make sure it gets access to your `useAuth`, if it needs it."
        );
      }
      fs5.writeFileSync(webAppPath, content);
    }
  };
};
var createWebAuth = (basedir, webAuthn) => {
  const templatesBaseDir = path5.join(basedir, "templates", "web");
  const templates = fs5.readdirSync(templatesBaseDir);
  const templateFileName = templates.find((template) => {
    return template.startsWith("auth." + (webAuthn ? "webAuthn.ts" : "ts"));
  });
  if (!templateFileName) {
    throw new Error("Could not find the auth.ts template");
  }
  const templateExtension = templateFileName.split(".").at(-2);
  const isTSProject = isTypeScriptProject();
  let ext = templateExtension;
  if (!isTypeScriptProject()) {
    ext = ext?.replace("ts", "js");
  }
  return {
    title: `Creating web/src/auth.${ext}`,
    task: async (ctx) => {
      let authFileName = path5.join(getPaths().web.src, "auth");
      if (ctx.setupMode === "COMBINE") {
        let i = 1;
        while (resolveFile2(authFileName)) {
          const count = i > 1 ? i : "";
          authFileName = path5.join(
            getPaths().web.src,
            ctx.provider + "Auth" + count
          );
          i++;
        }
      }
      authFileName = authFileName + "." + ext;
      let template = fs5.readFileSync(
        path5.join(templatesBaseDir, templateFileName),
        "utf-8"
      );
      template = isTSProject ? template : await transformTSToJS(authFileName, template);
      fs5.writeFileSync(authFileName, template);
    }
  };
};
var addConfigToRoutes = () => {
  return {
    title: "Updating Routes file...",
    task: () => {
      const webRoutesPath = getPaths().web.routes;
      let content = fs5.readFileSync(webRoutesPath).toString();
      if (!content.includes(AUTH_HOOK_IMPORT)) {
        content = addAuthImportToRoutes(content);
      }
      if (!hasUseAuthHook("Router", content)) {
        content = addUseAuthHook("Router", content);
      }
      fs5.writeFileSync(webRoutesPath, content);
    }
  };
};
var generateAuthApiFiles = (basedir, webAuthn) => {
  return {
    title: "Generating auth api side files...",
    task: async (ctx, task) => {
      if (!apiSrcDoesExist()) {
        return new Error(
          "Could not find api/src directory. Cannot continue setup!"
        );
      }
      let filesRecord = await apiSideFiles({ basedir, webAuthn });
      let existingFiles = "FAIL";
      if (ctx.setupMode === "FORCE") {
        existingFiles = "OVERWRITE";
      } else if (ctx.setupMode === "REPLACE") {
        const filesToOverwrite = findExistingFiles(filesRecord);
        const overwrite = await task.prompt({
          type: "confirm",
          message: `Overwrite existing ${filesToOverwrite.join(", ")}?`,
          initial: false
        });
        existingFiles = overwrite ? "OVERWRITE" : "SKIP";
      } else if (ctx.setupMode === "COMBINE") {
        const uniqueFilesRecord = generateUniqueFileNames(
          filesRecord,
          ctx.provider
        );
        filesRecord = uniqueFilesRecord;
        existingFiles = "FAIL";
      }
      return writeFilesTask(filesRecord, {
        existingFiles
      });
    }
  };
};
function findExistingFiles(filesMap) {
  return Object.keys(filesMap).filter((filePath) => fs5.existsSync(filePath)).map((filePath) => filePath.replace(getPaths().base, ""));
}
var addAuthConfigToGqlApi = (authDecoderImport) => ({
  title: "Adding auth config to GraphQL API...",
  task: (ctx, _task) => {
    if (graphFunctionDoesExist()) {
      addApiConfig({
        authDecoderImport,
        replaceExistingImport: ctx.setupMode === "REPLACE" || ctx.setupMode === "FORCE"
      });
    } else {
      throw new Error(
        "GraphQL function not found. You will need to pass the decoder to the createGraphQLHandler function."
      );
    }
  }
});
var setAuthSetupMode = (force) => {
  return {
    title: "Checking project for existing auth...",
    task: async (ctx, task) => {
      if (force) {
        ctx.setupMode = "FORCE";
        return;
      }
      const webAppContents = fs5.readFileSync(getWebAppPath(), "utf-8");
      if (hasAuthProvider(webAppContents) && ctx.setupMode === "UNKNOWN") {
        const setupMode = "REPLACE";
        ctx.setupMode = setupMode;
        return;
      } else {
        ctx.setupMode = "FORCE";
        task.skip("Setting up Auth from scratch");
      }
    }
  };
};

// src/auth/setupHelpers.ts
var standardAuthBuilder = (yargs) => {
  return yargs.option("force", {
    alias: "f",
    default: false,
    description: "Overwrite existing auth configuration",
    type: "boolean"
  }).option("verbose", {
    alias: "v",
    default: false,
    description: "Log setup output",
    type: "boolean"
  }).epilogue(
    `Also see the ${terminalLink(
      "Redwood CLI Reference",
      "https://redwoodjs.com/docs/cli-commands#setup-auth"
    )}`
  );
};
function truthy(value) {
  return !!value;
}
var standardAuthHandler = async ({
  basedir,
  forceArg,
  provider,
  authDecoderImport,
  webAuthn = false,
  webPackages = [],
  apiPackages = [],
  extraTasks,
  notes,
  verbose
}) => {
  const tasks = new Listr2(
    [
      setAuthSetupMode(forceArg),
      generateAuthApiFiles(basedir, webAuthn),
      addConfigToWebApp(),
      createWebAuth(basedir, webAuthn),
      addConfigToRoutes(),
      addAuthConfigToGqlApi(authDecoderImport),
      webPackages.length && addWebPackages(webPackages),
      apiPackages.length && addApiPackages(apiPackages),
      (webPackages.length || apiPackages.length) && installPackages,
      ...extraTasks || [],
      notes && {
        title: "One more thing...",
        task: (ctx) => {
          if (ctx.setupMode === "REPLACE") {
            notes.push(
              ...[
                "",
                `${colors.warning(
                  "Your existing auth provider has been replaced!"
                )}`,
                "You'll still need to manually remove your old auth provider's config,",
                "functions, and dependencies (in your web and api package.json's)."
              ]
            );
          }
          if (ctx.setupMode === "COMBINE") {
            notes.push(
              colors.warning(
                `To avoid overwriting existing files we've generated new file names for the newly generated files. This probably means ${ctx.provider} auth doesn't work out of the box. You'll most likely have to manually merge some of the generated files with your existing auth files`
              )
            );
          }
        }
      }
    ].filter(truthy),
    {
      rendererOptions: { collapseSubtasks: false },
      renderer: verbose ? "verbose" : "default",
      ctx: {
        setupMode: "UNKNOWN",
        provider
        // provider name passed from CLI
      }
    }
  );
  try {
    await tasks.run();
    notes && console.log(`
   ${notes.join("\n   ")}
`);
  } catch (e) {
    if (isErrorWithMessage2(e)) {
      errorTelemetry(process.argv, e.message);
      console.error(colors.error(e.message));
    }
    if (isErrorWithErrorCode(e)) {
      process.exit(e.exitCode || 1);
    } else {
      process.exit(1);
    }
  }
};
function isErrorWithMessage2(e) {
  return !!e.message;
}
function isErrorWithErrorCode(e) {
  return !isNaN(e.exitCode);
}

// src/telemetry/index.ts
import opentelemetry, { SpanStatusCode } from "@opentelemetry/api";
function recordTelemetryAttributes(attributes, span) {
  const spanToRecord = span ?? opentelemetry.trace.getActiveSpan();
  if (spanToRecord === void 0) {
    return;
  }
  for (const [key, value] of Object.entries(attributes)) {
    spanToRecord.setAttribute(key, value);
  }
}
function recordTelemetryError(error, span) {
  const spanToRecord = span ?? opentelemetry.trace.getActiveSpan();
  if (spanToRecord === void 0) {
    return;
  }
  const message = error?.message ?? error?.toString() ?? "Unknown error";
  const firstLineOfError = message.split("\n")[0];
  spanToRecord.setStatus({
    code: SpanStatusCode.ERROR,
    message: firstLineOfError
  });
  spanToRecord.recordException(error ?? new Error(firstLineOfError));
}
export {
  addApiPackages,
  addEnvVar,
  addEnvVarTask,
  addRootPackages,
  addWebPackages,
  colors,
  getCompatibilityData,
  getGraphqlPath,
  getInstalledRedwoodVersion,
  getPaths,
  getPrettierOptions,
  graphFunctionDoesExist,
  installPackages,
  isTypeScriptProject,
  prettify,
  recordTelemetryAttributes,
  recordTelemetryError,
  setRedwoodCWD,
  setTomlSetting,
  standardAuthBuilder,
  standardAuthHandler,
  transformTSToJS,
  updateTomlConfig,
  updateTomlConfigTask,
  writeFile,
  writeFilesTask
};
