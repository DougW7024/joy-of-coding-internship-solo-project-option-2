"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.createAuth = createAuth;
exports.createDbAuthClient = createDbAuthClient;
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));
var _auth = require("@redwoodjs/auth");
const TOKEN_CACHE_TIME = 5000;
function createAuth(dbAuthClient, customProviderHooks) {
  return (0, _auth.createAuthentication)(dbAuthClient, customProviderHooks);
}
function createDbAuthClient({
  webAuthn,
  dbAuthUrl,
  fetchConfig
} = {}) {
  const credentials = fetchConfig?.credentials || 'same-origin';
  webAuthn?.setAuthApiUrl(dbAuthUrl);
  let getTokenPromise;
  let lastTokenCheckAt = new Date('1970-01-01T00:00:00');
  let cachedToken;
  const getApiDbAuthUrl = () => {
    return dbAuthUrl || `${RWJS_API_URL}/auth`;
  };
  const resetAndFetch = async (...params) => {
    resetTokenCache();
    return fetch(...params);
  };
  const isTokenCacheExpired = () => {
    const now = new Date();
    return now.getTime() - lastTokenCheckAt.getTime() > TOKEN_CACHE_TIME;
  };
  const resetTokenCache = () => {
    lastTokenCheckAt = new Date('1970-01-01T00:00:00');
    cachedToken = null;
  };
  const forgotPassword = async username => {
    const response = await resetAndFetch(getApiDbAuthUrl(), {
      credentials,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: (0, _stringify.default)({
        username,
        method: 'forgotPassword'
      })
    });
    return response.json();
  };
  const getToken = async () => {
    // Return the existing fetch promise, so that parallel calls
    // to getToken only cause a single fetch
    if (getTokenPromise) {
      return getTokenPromise;
    }
    if (isTokenCacheExpired()) {
      getTokenPromise = fetch(`${getApiDbAuthUrl()}?method=getToken`, {
        credentials
      }).then(response => response.text()).then(tokenText => {
        lastTokenCheckAt = new Date();
        cachedToken = tokenText.length === 0 ? null : tokenText;
        return cachedToken;
      }).catch(() => {
        return null;
      }).finally(() => {
        getTokenPromise = null;
      });
      return getTokenPromise;
    }
    return cachedToken;
  };
  const login = async ({
    username,
    password
  }) => {
    const response = await resetAndFetch(getApiDbAuthUrl(), {
      credentials,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: (0, _stringify.default)({
        username,
        password,
        method: 'login'
      })
    });
    return response.json();
  };
  const logout = async () => {
    await resetAndFetch(getApiDbAuthUrl(), {
      credentials,
      method: 'POST',
      body: (0, _stringify.default)({
        method: 'logout'
      })
    });
    return true;
  };
  const resetPassword = async attributes => {
    const response = await resetAndFetch(getApiDbAuthUrl(), {
      credentials,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: (0, _stringify.default)({
        ...attributes,
        method: 'resetPassword'
      })
    });
    return response.json();
  };
  const signup = async attributes => {
    const response = await resetAndFetch(getApiDbAuthUrl(), {
      credentials,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: (0, _stringify.default)({
        ...attributes,
        method: 'signup'
      })
    });
    return response.json();
  };
  const validateResetToken = async resetToken => {
    const response = await resetAndFetch(getApiDbAuthUrl(), {
      credentials,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: (0, _stringify.default)({
        resetToken,
        method: 'validateResetToken'
      })
    });
    return response.json();
  };
  return {
    type: 'dbAuth',
    client: webAuthn,
    login,
    logout,
    signup,
    getToken,
    getUserMetadata: getToken,
    forgotPassword,
    resetPassword,
    validateResetToken
  };
}