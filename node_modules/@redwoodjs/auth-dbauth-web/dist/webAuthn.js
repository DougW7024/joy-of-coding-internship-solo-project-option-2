"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));
require("core-js/modules/esnext.json.parse.js");
var _browser = require("@simplewebauthn/browser");
class WebAuthnRegistrationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'WebAuthnRegistrationError';
  }
}
class WebAuthnAuthenticationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'WebAuthnAuthenticationError';
  }
}
class WebAuthnAlreadyRegisteredError extends WebAuthnRegistrationError {
  constructor() {
    super('This device is already registered');
    this.name = 'WebAuthnAlreadyRegisteredError';
  }
}
class WebAuthnDeviceNotFoundError extends WebAuthnAuthenticationError {
  constructor() {
    super('WebAuthn device not found');
    this.name = 'WebAuthnDeviceNotFoundError';
  }
}
class WebAuthnNoAuthenticatorError extends WebAuthnAuthenticationError {
  constructor() {
    super("This device was not recognized. Use username/password login, or if you're using iOS you can try reloading this page");
    this.name = 'WebAuthnNoAuthenticatorError';
  }
}
class WebAuthnClient {
  constructor() {
    this.authApiUrl = '';
  }
  getAuthApiUrl() {
    return this.authApiUrl || `${RWJS_API_URL}/auth`;
  }
  setAuthApiUrl(authApiUrl) {
    if (authApiUrl) {
      this.authApiUrl = authApiUrl;
    }
  }
  async isSupported() {
    return await (0, _browser.browserSupportsWebAuthn)();
  }
  isEnabled() {
    return !!/\bwebAuthn\b/.test(document.cookie);
  }
  async authenticationOptions() {
    let options;
    try {
      const xhr = new XMLHttpRequest();
      xhr.withCredentials = true;
      xhr.open('GET', `${this.getAuthApiUrl()}?method=webAuthnAuthOptions`, false);
      xhr.setRequestHeader('content-type', 'application/json');
      xhr.send(null);
      options = JSON.parse(xhr.responseText);
      if (xhr.status !== 200) {
        if (options.error?.match(/username and password/)) {
          throw new WebAuthnDeviceNotFoundError();
        } else {
          throw new WebAuthnAuthenticationError(`Could not start authentication: ${options.error}`);
        }
      }
    } catch (e) {
      console.error(e.message);
      throw new WebAuthnAuthenticationError(`Could not start authentication: ${e.message}`);
    }
    return options;
  }
  async authenticate() {
    const authOptions = await this.authenticationOptions();
    try {
      const browserResponse = await (0, _browser.startAuthentication)(authOptions);
      const xhr = new XMLHttpRequest();
      xhr.withCredentials = true;
      xhr.open('POST', this.getAuthApiUrl(), false);
      xhr.setRequestHeader('content-type', 'application/json');
      xhr.send((0, _stringify.default)({
        method: 'webAuthnAuthenticate',
        ...browserResponse
      }));
      const options = JSON.parse(xhr.responseText);
      if (xhr.status !== 200) {
        throw new WebAuthnAuthenticationError(`Could not complete authentication: ${options.error}`);
      }
    } catch (e) {
      if (e.message.match(/No available authenticator recognized any of the allowed credentials/)) {
        throw new WebAuthnNoAuthenticatorError();
      } else {
        throw new WebAuthnAuthenticationError(`Error while authenticating: ${e.message}`);
      }
    }
    return true;
  }
  registrationOptions() {
    let options;
    try {
      const xhr = new XMLHttpRequest();
      xhr.withCredentials = true;
      xhr.open('GET', `${this.getAuthApiUrl()}?method=webAuthnRegOptions`, false);
      xhr.setRequestHeader('content-type', 'application/json');
      xhr.send(null);
      options = JSON.parse(xhr.responseText);
      if (xhr.status !== 200) {
        throw new WebAuthnRegistrationError(`Could not start registration: ${options.error}`);
      }
    } catch (e) {
      console.error(e);
      throw new WebAuthnRegistrationError(`Could not start registration: ${e.message}`);
    }
    return options;
  }
  async register() {
    const options = await this.registrationOptions();
    let regResponse;
    try {
      regResponse = await (0, _browser.startRegistration)(options);
    } catch (e) {
      if (e.name === 'InvalidStateError') {
        throw new WebAuthnAlreadyRegisteredError();
      } else {
        throw new WebAuthnRegistrationError(`Error while registering: ${e.message}`);
      }
    }
    try {
      const xhr = new XMLHttpRequest();
      xhr.withCredentials = true;
      xhr.open('POST', this.getAuthApiUrl(), false);
      xhr.setRequestHeader('content-type', 'application/json');
      xhr.send((0, _stringify.default)({
        method: 'webAuthnRegister',
        ...regResponse
      }));
      const options = JSON.parse(xhr.responseText);
      if (xhr.status !== 200) {
        throw new WebAuthnRegistrationError(`Could not complete registration: ${options.error}`);
      }
    } catch (e) {
      throw new WebAuthnRegistrationError(`Error while registering: ${e.message}`);
    }
    return true;
  }
}
exports.default = WebAuthnClient;