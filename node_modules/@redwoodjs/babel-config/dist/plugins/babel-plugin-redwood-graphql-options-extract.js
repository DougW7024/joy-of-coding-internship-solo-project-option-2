"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var babel_plugin_redwood_graphql_options_extract_exports = {};
__export(babel_plugin_redwood_graphql_options_extract_exports, {
  default: () => babel_plugin_redwood_graphql_options_extract_default
});
module.exports = __toCommonJS(babel_plugin_redwood_graphql_options_extract_exports);
const exportVariableName = "__rw_graphqlOptions";
function optionsConstNode(t, value, state) {
  if (t.isIdentifier(value) || t.isObjectExpression(value) || t.isCallExpression(value) || t.isConditionalExpression(value)) {
    return t.exportNamedDeclaration(
      t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier(exportVariableName), value)
      ])
    );
  } else {
    throw new Error(
      `Unable to parse graphql function options in '${state.file.opts.filename}'`
    );
  }
}
function babel_plugin_redwood_graphql_options_extract_default({ types: t }) {
  return {
    name: "babel-plugin-redwood-graphql-options-extract",
    visitor: {
      ExportNamedDeclaration(path, state) {
        const declaration = path.node.declaration;
        if (declaration?.type !== "VariableDeclaration") {
          return;
        }
        const declarator = declaration.declarations[0];
        if (declarator?.type !== "VariableDeclarator") {
          return;
        }
        const identifier = declarator.id;
        if (identifier?.type !== "Identifier") {
          return;
        }
        if (identifier.name !== "handler") {
          return;
        }
        const init = declarator.init;
        if (init?.type !== "CallExpression") {
          return;
        }
        const options = init.arguments[0];
        path.insertBefore(optionsConstNode(t, options, state));
        init.arguments[0] = t.identifier(exportVariableName);
      }
    }
  };
}
