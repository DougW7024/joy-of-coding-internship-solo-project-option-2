"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.registerFragments = exports.registerFragment = exports.fragmentRegistry = void 0;
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var apolloClient = _interopRequireWildcard(require("@apollo/client"));
var _cache = require("@apollo/client/cache");
var _utilities = require("@apollo/client/utilities");
/*
 * Get the typename from a fragment.
 */
const getTypenameFromFragment = fragment => {
  const [definition] = (0, _utilities.getFragmentDefinitions)(fragment);
  return definition.typeCondition.name.value;
};

/**
 *
 * Relies on the useFragment hook which represents a lightweight
 * live binding into the Apollo Client Cache.
 *
 * It enables Apollo Client to broadcast specific fragment results to
 * individual components.
 *
 * This hook returns an always-up-to-date view of whatever data the
 * cache currently contains for a given fragment.
 *
 * useFragment never triggers network requests of its own.
 *
 * @see https://www.apollographql.com/docs/react/api/react/hooks#usefragment
 */
const useRegisteredFragmentHook = (fragment, id) => {
  const from = {
    __typename: getTypenameFromFragment(fragment),
    id
  };
  return apolloClient.useFragment({
    fragment,
    from
  });
};

/**
 * Creates a fragment registry for Apollo Client's InMemoryCache so that they
 * can be referred to by name in any query or InMemoryCache operation
 * (such as cache.readFragment, cache.readQuery and cache.watch)
 * without needing to interpolate their declaration.
 *
 * @see https://www.apollographql.com/docs/react/data/fragments/#registering-named-fragments-using-createfragmentregistry
 **/
const fragmentRegistry = exports.fragmentRegistry = (0, _cache.createFragmentRegistry)();

/**
 * Registers a list of fragments with the fragment registry.
 */
const registerFragments = fragments => {
  return (0, _map.default)(fragments).call(fragments, registerFragment);
};

/**
 * Registers a fragment with the fragment registry.
 *
 * It returns a set of utilities for working with the fragment, including:
 * - the fragment itself
 * - the typename of the fragment
 * - a function to get the cache key for a given id
 * - a hook to use the registered fragment in a component by id
 * that returns cached data for the fragment
 *
 * Note: one does not need to use the hook, cacheKey to use the fragment in queries.
 *
 * @see https://www.apollographql.com/docs/react/data/fragments/#registering-named-fragments-using-createfragmentregistry
 */
exports.registerFragments = registerFragments;
const registerFragment = fragment => {
  fragmentRegistry.register(fragment);
  const typename = getTypenameFromFragment(fragment);
  const getCacheKey = id => {
    return {
      __typename: typename,
      id
    };
  };
  const useRegisteredFragment = id => {
    return useRegisteredFragmentHook(fragment, id);
  };
  return {
    fragment,
    typename,
    getCacheKey,
    useRegisteredFragment
  };
};
exports.registerFragment = registerFragment;