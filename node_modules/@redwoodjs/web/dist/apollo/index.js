"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.RedwoodApolloProvider = void 0;
_Object$defineProperty(exports, "fragmentRegistry", {
  enumerable: true,
  get: function () {
    return _fragmentRegistry.fragmentRegistry;
  }
});
_Object$defineProperty(exports, "registerFragment", {
  enumerable: true,
  get: function () {
    return _fragmentRegistry.registerFragment;
  }
});
_Object$defineProperty(exports, "registerFragments", {
  enumerable: true,
  get: function () {
    return _fragmentRegistry.registerFragments;
  }
});
_Object$defineProperty(exports, "useCache", {
  enumerable: true,
  get: function () {
    return _useCache.useCache;
  }
});
var _react = _interopRequireDefault(require("react"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/concat"));
var _globalThis2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/global-this"));
var apolloClient = _interopRequireWildcard(require("@apollo/client"));
var _context3 = require("@apollo/client/link/context");
var _persistedQueries = require("@apollo/client/link/persisted-queries");
var _utilities = require("@apollo/client/utilities");
var _printer = require("graphql/language/printer");
var _auth = require("@redwoodjs/auth");
require("./typeOverride");
var _FetchConfigProvider = require("../components/FetchConfigProvider.js");
var _GraphQLHooksProvider = require("../components/GraphQLHooksProvider.js");
var _fragmentRegistry = require("./fragmentRegistry.js");
var _sseLink = require("./sseLink.js");
var _useCache = require("./useCache.js");
var _jsxRuntime = require("react/jsx-runtime");
// Note: Importing directly from `apollo/client` doesn't work properly in Storybook.
const {
  ApolloProvider,
  ApolloClient,
  ApolloLink,
  HttpLink,
  InMemoryCache,
  useQuery,
  useMutation,
  useSubscription,
  setLogVerbosity: apolloSetLogVerbosity
} = apolloClient;
const ApolloProviderWithFetchConfig = _ref => {
  var _context2;
  let {
    config,
    children,
    useAuth = _auth.useNoAuth,
    logLevel
  } = _ref;
  // Should they run into it, this helps users with the "Cannot render cell; GraphQL success but data is null" error.
  // See https://github.com/redwoodjs/redwood/issues/2473.
  apolloSetLogVerbosity(logLevel);

  // Here we're using Apollo Link to customize Apollo Client's data flow.
  // Although we're sending conventional HTTP-based requests and could just pass `uri` instead of `link`,
  // we need to fetch a new token on every request, making middleware a good fit for this.
  //
  // See https://www.apollographql.com/docs/react/api/link/introduction.
  const {
    getToken,
    type: authProviderType
  } = useAuth();

  // `updateDataApolloLink` keeps track of the most recent req/res data so they can be passed to
  // any errors passed up to an error boundary.

  const data = {
    mostRecentRequest: undefined,
    mostRecentResponse: undefined
  };
  const updateDataApolloLink = new ApolloLink((operation, forward) => {
    var _context;
    const {
      operationName,
      query,
      variables
    } = operation;
    data.mostRecentRequest = {};
    data.mostRecentRequest.operationName = operationName;
    data.mostRecentRequest.operationKind = query?.kind.toString();
    data.mostRecentRequest.variables = variables;
    data.mostRecentRequest.query = query && (0, _printer.print)(operation.query);
    return (0, _map.default)(_context = forward(operation)).call(_context, result => {
      data.mostRecentResponse = result;
      return result;
    });
  });
  const withToken = (0, _context3.setContext)(async () => {
    const token = await getToken();
    return {
      token
    };
  });
  const {
    headers,
    uri
  } = (0, _FetchConfigProvider.useFetchConfig)();
  const authMiddleware = new ApolloLink((operation, forward) => {
    const {
      token
    } = operation.getContext();

    // Only add auth headers when there's a token. `token` is `null` when `!isAuthenticated`.
    const authHeaders = token ? {
      'auth-provider': authProviderType,
      authorization: `Bearer ${token}`
    } : {};
    operation.setContext(() => ({
      headers: {
        ...operation.getContext().headers,
        ...headers,
        // Duped auth headers, because we may remove the `FetchConfigProvider` at a later date.
        ...authHeaders
      }
    }));
    return forward(operation);
  });
  const {
    httpLinkConfig,
    link: redwoodApolloLink,
    ...rest
  } = config !== null && config !== void 0 ? config : {};

  // A terminating link. Apollo Client uses this to send GraphQL operations to a server over HTTP.
  // See https://www.apollographql.com/docs/react/api/link/introduction/#the-terminating-link.
  const httpLink = new HttpLink({
    uri,
    ...httpLinkConfig
  });

  // Our terminating link needs to be smart enough to handle subscriptions, and if the GraphQL query
  // is subscription it needs to use the SSELink (server sent events link).
  const httpOrSSELink = typeof _sseLink.SSELink !== 'undefined' ? apolloClient.split(_ref2 => {
    let {
      query
    } = _ref2;
    const definition = (0, _utilities.getMainDefinition)(query);
    return definition.kind === 'OperationDefinition' && definition.operation === 'subscription';
  }, new _sseLink.SSELink({
    url: uri,
    auth: {
      authProviderType,
      tokenFn: getToken
    },
    httpLinkConfig,
    headers
  }), httpLink) : httpLink;

  /**
   * Use Trusted Documents aka Persisted Operations aka Queries
   *
   * When detecting a meta hash, Apollo Client will send the hash from the document and not the query itself.
   *
   * You must configure your GraphQL server to support this feature with the useTrustedDocuments option.
   *
   * See https://www.apollographql.com/docs/react/api/link/persisted-queries/
   */

  // Check if the query made includes the hash, and if so then make the request with the persisted query link
  const terminatingLink = apolloClient.split(_ref3 => {
    let {
      query
    } = _ref3;
    const documentQuery = query;
    return documentQuery?.['__meta__']?.['hash'] !== undefined;
  }, (0, _concat.default)(_context2 = (0, _persistedQueries.createPersistedQueryLink)({
    generateHash: document => document['__meta__']['hash']
  })).call(_context2, httpOrSSELink), httpOrSSELink);

  // The order here is important. The last link *must* be a terminating link like HttpLink, SSELink, or the PersistedQueryLink.
  const redwoodApolloLinks = [{
    name: 'withToken',
    link: withToken
  }, {
    name: 'authMiddleware',
    link: authMiddleware
  }, {
    name: 'updateDataApolloLink',
    link: updateDataApolloLink
  }, {
    name: 'httpLink',
    link: terminatingLink
  }];
  let link = redwoodApolloLink;
  link ??= ApolloLink.from((0, _map.default)(redwoodApolloLinks).call(redwoodApolloLinks, l => l.link));
  if (typeof link === 'function') {
    link = link(redwoodApolloLinks);
  }
  const client = new ApolloClient({
    // Default options for every Cell. Better to specify them here than in `beforeQuery` where it's too easy to overwrite them.
    // See https://www.apollographql.com/docs/react/api/core/ApolloClient/#example-defaultoptions-object.
    defaultOptions: {
      watchQuery: {
        // The `fetchPolicy` we expect:
        //
        // > Apollo Client executes the full query against both the cache and your GraphQL server.
        // > The query automatically updates if the result of the server-side query modifies cached fields.
        //
        // See https://www.apollographql.com/docs/react/data/queries/#cache-and-network.
        fetchPolicy: 'cache-and-network',
        // So that Cells rerender when refetching.
        // See https://www.apollographql.com/docs/react/data/queries/#inspecting-loading-states.
        notifyOnNetworkStatusChange: true
      }
    },
    link,
    ...rest
  });
  const extendErrorAndRethrow = (error, _errorInfo) => {
    error['mostRecentRequest'] = data.mostRecentRequest;
    error['mostRecentResponse'] = data.mostRecentResponse;
    throw error;
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(ApolloProvider, {
    client: client,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(ErrorBoundary, {
      onError: extendErrorAndRethrow,
      children: children
    })
  });
};
class ErrorBoundary extends _react.default.Component {
  componentDidCatch() {
    this.setState({});
    this.props.onError(...arguments);
  }
  render() {
    return this.props.children;
  }
}
const RedwoodApolloProvider = _ref4 => {
  var _globalThis$__REDWOOD;
  let {
    graphQLClientConfig,
    fragments,
    useAuth = _auth.useNoAuth,
    logLevel = 'debug',
    children
  } = _ref4;
  // Since Apollo Client gets re-instantiated on auth changes,
  // we have to instantiate `InMemoryCache` here, so that it doesn't get wiped.
  const {
    cacheConfig,
    ...config
  } = graphQLClientConfig !== null && graphQLClientConfig !== void 0 ? graphQLClientConfig : {};

  // Auto register fragments
  if (fragments) {
    _fragmentRegistry.fragmentRegistry.register(...fragments);
  }
  const cache = new InMemoryCache({
    fragments: _fragmentRegistry.fragmentRegistry,
    possibleTypes: cacheConfig?.possibleTypes,
    ...cacheConfig
  }).restore((_globalThis$__REDWOOD = _globalThis2.default?.__REDWOOD__APOLLO_STATE) !== null && _globalThis$__REDWOOD !== void 0 ? _globalThis$__REDWOOD : {});
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_FetchConfigProvider.FetchConfigProvider, {
    useAuth: useAuth,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(ApolloProviderWithFetchConfig
    // This order so that the user can still completely overwrite the cache.
    , {
      config: {
        cache,
        ...config
      },
      useAuth: useAuth,
      logLevel: logLevel,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_GraphQLHooksProvider.GraphQLHooksProvider, {
        useQuery: useQuery,
        useMutation: useMutation,
        useSubscription: useSubscription,
        children: children
      })
    })
  });
};
exports.RedwoodApolloProvider = RedwoodApolloProvider;