"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.executeQuery = executeQuery;
exports.getGqlHandler = getGqlHandler;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));
var _path = _interopRequireDefault(require("path"));
var _graphql = require("graphql");
var _projectConfig = require("@redwoodjs/project-config");
var _graphql2 = require("@redwoodjs/web/dist/graphql");
var _errors = require("../errors");
// @MARK: have to do this, otherwise rwjs/web is loaded before shims

/**
 * Loads the graphql server, with all the user's settings
 * And execute the query against it
 *
 * Note that this function does NOT throw errors, even when
 * there is a GraphQL error. Instead, it returns the result with the graphql error.
 *
 * @returns {Promise<QueryResult>}
 */
async function executeQuery(gqlHandler, query, variables) {
  const config = (0, _projectConfig.getConfig)();
  const operationName = (0, _graphql2.getOperationName)(query);
  const operation = {
    operationName,
    query: (0, _graphql.print)(query),
    variables
  };

  // If Trusted Documents support is enabled, we shouldn't send the actual
  // query, but rather the hash of the query. We find this hash by looking in
  // the generated types file /web/src/graphql/graphql.ts (notice that it's
  // generated on the web side)
  if (config.graphql.trustedDocuments) {
    const documentsPath = _path.default.join((0, _projectConfig.getPaths)().web.graphql, 'graphql');
    const documents = require(documentsPath);
    const documentName = operationName[0].toUpperCase() + (0, _slice.default)(operationName).call(operationName, 1) + 'Document';
    const queryHash = documents?.[documentName]?.__meta__?.hash;
    operation.query = undefined;
    operation.extensions = {
      persistedQuery: {
        version: 1,
        sha256Hash: queryHash
      }
    };
  }
  const handlerResult = await gqlHandler(operation);
  return handlerResult?.body;
}

/**
 * Finds the graphql handler, returns a function
 * that can be used to execute queries against it
 *
 * Throws GqlHandlerImportError, so that we can warn the user (but not blow up)
 */
async function getGqlHandler() {
  const gqlPath = _path.default.join((0, _projectConfig.getPaths)().api.functions, 'graphql');
  try {
    const {
      handler
    } = require(gqlPath);
    return async operation => {
      return await handler(buildApiEvent(operation), buildContext());
    };
  } catch (e) {
    return () => {
      throw new _errors.GqlHandlerImportError(`Unable to import GraphQL handler at ${gqlPath}`);
    };
  }
}
function buildApiEvent(body) {
  return {
    body: (0, _stringify.default)(body),
    headers: {
      origin: 'http://localhost:8910',
      'content-type': 'application/json',
      accept: '*/*',
      host: 'localhost:8910'
    },
    multiValueHeaders: {},
    httpMethod: 'POST',
    isBase64Encoded: false,
    path: '/graphql',
    pathParameters: null,
    queryStringParameters: {},
    multiValueQueryStringParameters: null,
    stageVariables: null,
    resource: '',
    requestContext: {
      requestId: 'req-3',
      identity: {
        sourceIp: '::1',
        accessKey: null,
        accountId: null,
        apiKey: null,
        apiKeyId: null,
        caller: null,
        clientCert: null,
        cognitoAuthenticationProvider: null,
        cognitoAuthenticationType: null,
        cognitoIdentityId: null,
        cognitoIdentityPoolId: null,
        principalOrgId: null,
        user: null,
        userAgent: null,
        userArn: null
      },
      authorizer: {},
      protocol: 'http',
      httpMethod: 'POST',
      path: '/graphql',
      stage: '',
      requestTimeEpoch: 0,
      resourceId: '',
      resourcePath: '',
      accountId: '',
      apiId: ''
    }
  };
}
function buildContext() {
  return {
    callbackWaitsForEmptyEventLoop: false,
    functionName: '',
    functionVersion: '',
    invokedFunctionArn: '',
    memoryLimitInMB: '',
    awsRequestId: '',
    logGroupName: '',
    logStreamName: '',
    getRemainingTimeInMillis: () => 100,
    done: () => {},
    fail: () => {},
    succeed: () => {}
  };
}