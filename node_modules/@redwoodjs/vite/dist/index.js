"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  default: () => redwoodPluginVite
});
module.exports = __toCommonJS(src_exports);
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_plugin_react = __toESM(require("@vitejs/plugin-react"));
var import_vite = require("vite");
var import_babel_config = require("@redwoodjs/babel-config");
var import_project_config = require("@redwoodjs/project-config");
var import_vite_plugin_jsx_loader = __toESM(require("./plugins/vite-plugin-jsx-loader.js"));
var import_vite_plugin_remove_from_bundle = __toESM(require("./plugins/vite-plugin-remove-from-bundle.js"));
function redwoodPluginVite() {
  const rwPaths = (0, import_project_config.getPaths)();
  const rwConfig = (0, import_project_config.getConfig)();
  const clientEntryPath = rwPaths.web.entryClient;
  if (!clientEntryPath) {
    throw new Error(
      "Vite client entry point not found. Please check that your project has an entry.client.{jsx,tsx} file in the web/src directory."
    );
  }
  const relativeEntryPath = import_path.default.relative(rwPaths.web.src, clientEntryPath);
  const apiPackageJsonPath = import_path.default.join(rwPaths.api.base, "package.json");
  const realtimeEnabled = import_fs.default.existsSync(apiPackageJsonPath) && import_fs.default.readFileSync(apiPackageJsonPath, "utf-8").includes("@redwoodjs/realtime");
  return [
    {
      name: "redwood-plugin-vite-html-env",
      // Vite can support replacing environment variables in index.html but
      // there are currently two issues with that:
      // 1. It requires the environment variables to be exposed on
      //    `import.meta.env`, but we expose them on `process.env` in Redwood.
      // 2. There's an open issue on Vite where it adds extra quotes around
      //    the replaced values, which breaks trying to use environment
      //    variables in src attributes for example.
      // Until those issues are resolved, we'll do the replacement ourselves
      // instead using transformIndexHtml. Doing it this was was also the
      // recommended way until Vite added built-in support for it.
      //
      // Extra quotes issue: https://github.com/vitejs/vite/issues/13424
      // transformIndexHtml being the recommended way:
      //   https://github.com/vitejs/vite/issues/3105#issuecomment-1059975023
      transformIndexHtml: {
        // Setting order: 'pre' so that it runs before the built-in
        // html env replacement.
        order: "pre",
        handler: (html) => {
          let newHtml = html;
          rwConfig.web.includeEnvironmentVariables.map((envName) => {
            newHtml = newHtml.replaceAll(
              `%${envName}%`,
              process.env[envName] || ""
            );
          });
          Object.entries(process.env).forEach(([envName, value]) => {
            if (envName.startsWith("REDWOOD_ENV_")) {
              newHtml = newHtml.replaceAll(`%${envName}%`, value || "");
            }
          });
          return newHtml;
        }
      }
    },
    {
      name: "redwood-plugin-vite",
      // ---------- Bundle injection ----------
      // Used by Vite during dev, to inject the entrypoint.
      transformIndexHtml: {
        order: "pre",
        handler: (html) => {
          if (import_fs.default.existsSync(clientEntryPath)) {
            return html.replace(
              "</head>",
              // @NOTE the slash in front, for windows compatibility and for pages in subdirectories
              `<script type="module" src="/${relativeEntryPath}"></script>
        </head>`
            );
          } else {
            return html;
          }
        }
      },
      // Used by rollup during build to inject the entrypoint
      // but note index.html does not come through as an id during dev
      transform: (code, id) => {
        if (import_fs.default.existsSync(clientEntryPath) && (0, import_vite.normalizePath)(id) === (0, import_vite.normalizePath)(rwPaths.web.html)) {
          return {
            code: code.replace(
              "</head>",
              `<script type="module" src="/${relativeEntryPath}"></script>
        </head>`
            ),
            map: null
          };
        } else {
          return {
            code,
            map: null
            // Returning null here preserves the original sourcemap
          };
        }
      },
      // ---------- End Bundle injection ----------
      config: (options, env) => {
        let apiHost = process.env.REDWOOD_API_HOST;
        apiHost ??= rwConfig.api.host;
        apiHost ??= process.env.NODE_ENV === "production" ? "0.0.0.0" : "[::]";
        let apiPort;
        if (process.env.REDWOOD_API_PORT) {
          apiPort = parseInt(process.env.REDWOOD_API_PORT);
        } else {
          apiPort = rwConfig.api.port;
        }
        return {
          root: rwPaths.web.src,
          // Disabling for now, let babel handle this for consistency
          // resolve: {
          //   alias: [
          //     {
          //       find: 'src',
          //       replacement: redwoodPaths.web.src,
          //     },
          //   ],
          // },
          envPrefix: "REDWOOD_ENV_",
          publicDir: import_path.default.join(rwPaths.web.base, "public"),
          define: {
            RWJS_ENV: {
              // @NOTE we're avoiding process.env here, unlike webpack
              RWJS_API_GRAPHQL_URL: rwConfig.web.apiGraphQLUrl ?? rwConfig.web.apiUrl + "/graphql",
              RWJS_API_URL: rwConfig.web.apiUrl,
              __REDWOOD__APP_TITLE: rwConfig.web.title || import_path.default.basename(rwPaths.base)
            },
            RWJS_DEBUG_ENV: {
              RWJS_SRC_ROOT: rwPaths.web.src,
              REDWOOD_ENV_EDITOR: JSON.stringify(
                process.env.REDWOOD_ENV_EDITOR
              )
            },
            // Vite can automatically expose environment variables, but we
            // disable that in `buildFeServer.ts` by setting `envFile: false`
            // because we want to use our own logic for loading .env,
            // .env.defaults, etc
            // The two object spreads below will expose all environment
            // variables listed in redwood.toml and all environment variables
            // prefixed with REDWOOD_ENV_
            ...Object.fromEntries(
              rwConfig.web.includeEnvironmentVariables.flatMap((envName) => [
                [
                  `import.meta.env.${envName}`,
                  JSON.stringify(process.env[envName])
                ],
                [
                  `process.env.${envName}`,
                  JSON.stringify(process.env[envName])
                ]
              ])
            ),
            ...Object.entries(process.env).reduce(
              (acc, [key, value]) => {
                if (key.startsWith("REDWOOD_ENV_")) {
                  acc[`import.meta.env.${key}`] = JSON.stringify(value);
                  acc[`process.env.${key}`] = JSON.stringify(value);
                }
                return acc;
              },
              {}
            )
          },
          css: {
            // @NOTE config path is relative to where vite.config.js is if you use relative path
            // postcss: './config/',
            postcss: rwPaths.web.config
          },
          server: {
            open: rwConfig.browser.open,
            port: rwConfig.web.port,
            host: true,
            // Listen to all hosts
            proxy: {
              [rwConfig.web.apiUrl]: {
                target: `http://${apiHost}:${apiPort}`,
                changeOrigin: false,
                // Remove the `.redwood/functions` part, but leave the `/graphql`
                rewrite: (path2) => path2.replace(rwConfig.web.apiUrl, ""),
                configure: (proxy) => {
                  let waitingForApiServer = true;
                  setTimeout(() => {
                    waitingForApiServer = false;
                  }, 2500);
                  proxy.on("error", (err, _req, res) => {
                    if (waitingForApiServer && err.message.includes("ECONNREFUSED")) {
                      err.stack = "\u231B API Server launching, please refresh your page...";
                    }
                    const msg = {
                      errors: [
                        {
                          message: "The RedwoodJS API server is not available or is currently reloading. Please refresh."
                        }
                      ]
                    };
                    res.writeHead(203, {
                      "Content-Type": "application/json",
                      "Cache-Control": "no-cache"
                    });
                    res.write(JSON.stringify(msg));
                    res.end();
                  });
                }
              }
            }
          },
          build: {
            outDir: options.build?.outDir || rwPaths.web.dist,
            emptyOutDir: true,
            manifest: !env.ssrBuild ? "build-manifest.json" : void 0,
            sourcemap: !env.ssrBuild && rwConfig.web.sourceMap
            // Note that this can be boolean or 'inline'
          },
          // To produce a cjs bundle for SSR
          legacy: {
            buildSsrCjsExternalHeuristics: env.ssrBuild
          },
          optimizeDeps: {
            esbuildOptions: {
              // @MARK this is because JS projects in Redwood don't have .jsx extensions
              loader: {
                ".js": "jsx"
              },
              // Node.js global to browser globalThis
              // @MARK unsure why we need this, but required for DevFatalErrorPage atleast
              define: {
                global: "globalThis"
              }
            }
          }
        };
      }
    },
    (0, import_vite_plugin_jsx_loader.default)(),
    // Remove the splash-page from the bundle.
    (0, import_vite_plugin_remove_from_bundle.default)([
      {
        id: /@redwoodjs\/router\/dist\/splash-page/
      }
    ]),
    !realtimeEnabled && (0, import_vite_plugin_remove_from_bundle.default)([
      {
        id: /@redwoodjs\/web\/dist\/apollo\/sseLink/
      }
    ]),
    (0, import_plugin_react.default)({
      babel: {
        ...(0, import_babel_config.getWebSideDefaultBabelConfig)({
          forVite: true
        })
      }
    })
  ];
}
