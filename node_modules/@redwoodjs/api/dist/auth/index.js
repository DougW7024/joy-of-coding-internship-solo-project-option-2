"use strict";

var _context2;
var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _forEachInstanceProperty = require("@babel/runtime-corejs3/core-js/instance/for-each");
var _Object$keys2 = require("@babel/runtime-corejs3/core-js/object/keys");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  getAuthProviderHeader: true,
  parseAuthorizationHeader: true,
  getAuthenticationContext: true
};
exports.parseAuthorizationHeader = exports.getAuthenticationContext = exports.getAuthProviderHeader = void 0;
var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));
var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/is-array"));
var _parseJWT = require("./parseJWT");
_forEachInstanceProperty(_context2 = _Object$keys2(_parseJWT)).call(_context2, function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _parseJWT[key]) return;
  _Object$defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _parseJWT[key];
    }
  });
});
var _event = require("../event");
// This is shared by `@redwoodjs/web`
const AUTH_PROVIDER_HEADER = 'auth-provider';
const getAuthProviderHeader = event => {
  var _context;
  const authProviderKey = (0, _find.default)(_context = (0, _keys.default)(event?.headers ?? {})).call(_context, key => key.toLowerCase() === AUTH_PROVIDER_HEADER);
  if (authProviderKey) {
    return (0, _event.getEventHeader)(event, authProviderKey);
  }
  return undefined;
};
exports.getAuthProviderHeader = getAuthProviderHeader;
/**
 * Split the `Authorization` header into a schema and token part.
 */
const parseAuthorizationHeader = event => {
  const parts = (0, _event.getEventHeader)(event, 'Authorization')?.split(' ');
  if (parts?.length !== 2) {
    throw new Error('The `Authorization` header is not valid.');
  }
  const [schema, token] = parts;
  if (!schema.length || !token.length) {
    throw new Error('The `Authorization` header is not valid.');
  }
  return {
    schema,
    token
  };
};

/** @MARK Note that we do not send LambdaContext when making fetch requests
 *
 * This part is incomplete, as we need to decide how we will make the breaking change to
 * 1. getCurrentUser
 * 2. authDecoders

 */
exports.parseAuthorizationHeader = parseAuthorizationHeader;
/**
 * Get the authorization information from the request headers and request context.
 * @returns [decoded, { type, schema, token }, { event, context }]
 **/
const getAuthenticationContext = async ({
  authDecoder,
  event,
  context
}) => {
  const type = getAuthProviderHeader(event);

  // No `auth-provider` header means that the user is logged out,
  // and none of this auth malarky is required.
  if (!type) {
    return undefined;
  }
  const {
    schema,
    token
  } = parseAuthorizationHeader(event);
  let authDecoders = [];
  if ((0, _isArray.default)(authDecoder)) {
    authDecoders = authDecoder;
  } else if (authDecoder) {
    authDecoders = [authDecoder];
  }
  let decoded = null;
  let i = 0;
  while (!decoded && i < authDecoders.length) {
    decoded = await authDecoders[i](token, type, {
      // @TODO: We will need to make a breaking change to support `Request` objects.
      // We can remove this typecast
      event: event,
      context
    });
    i++;
  }
  return [decoded, {
    type,
    schema,
    token
  }, {
    event,
    context
  }];
};
exports.getAuthenticationContext = getAuthenticationContext;