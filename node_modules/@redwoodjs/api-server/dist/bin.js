#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cliHelpers.ts
function getAPIHost() {
  let host = process.env.REDWOOD_API_HOST;
  host ??= (0, import_project_config.getConfig)().api.host;
  host ??= process.env.NODE_ENV === "production" ? "0.0.0.0" : "::";
  return host;
}
function getAPIPort() {
  return process.env.REDWOOD_API_PORT ? parseInt(process.env.REDWOOD_API_PORT) : (0, import_project_config.getConfig)().api.port;
}
function getWebHost() {
  let host = process.env.REDWOOD_WEB_HOST;
  host ??= (0, import_project_config.getConfig)().web.host;
  host ??= process.env.NODE_ENV === "production" ? "0.0.0.0" : "::";
  return host;
}
function getWebPort() {
  return process.env.REDWOOD_WEB_PORT ? parseInt(process.env.REDWOOD_WEB_PORT) : (0, import_project_config.getConfig)().web.port;
}
var import_project_config;
var init_cliHelpers = __esm({
  "src/cliHelpers.ts"() {
    "use strict";
    import_project_config = require("@redwoodjs/project-config");
  }
});

// src/fastify.ts
async function loadFastifyConfig() {
  const serverConfigPath = import_path.default.join(
    (0, import_project_config2.getPaths)().base,
    (0, import_project_config2.getConfig)().api.serverConfig
  );
  if (!import_fs.default.existsSync(serverConfigPath)) {
    return serverConfigFile;
  }
  if (!isServerConfigLoaded) {
    console.log(`Loading server config from ${serverConfigPath}`);
    const config2 = await import(`file://${serverConfigPath}`);
    serverConfigFile = { ...config2.default };
    isServerConfigLoaded = true;
  }
  return serverConfigFile;
}
var import_fs, import_path, import_fastify, import_store, import_project_config2, DEFAULT_OPTIONS, isServerConfigLoaded, serverConfigFile, createFastifyInstance, fastify_default;
var init_fastify = __esm({
  "src/fastify.ts"() {
    "use strict";
    import_fs = __toESM(require("fs"));
    import_path = __toESM(require("path"));
    import_fastify = __toESM(require("fastify"));
    import_store = require("@redwoodjs/context/dist/store");
    import_project_config2 = require("@redwoodjs/project-config");
    DEFAULT_OPTIONS = {
      logger: {
        level: process.env.NODE_ENV === "development" ? "debug" : "info"
      }
    };
    isServerConfigLoaded = false;
    serverConfigFile = {
      config: DEFAULT_OPTIONS,
      configureFastify: async (fastify, options) => {
        fastify.log.trace(
          options,
          `In configureFastify hook for side: ${options?.side}`
        );
        return fastify;
      }
    };
    createFastifyInstance = async (options) => {
      const { config: config2 } = await loadFastifyConfig();
      const fastify = (0, import_fastify.default)(options || config2 || DEFAULT_OPTIONS);
      fastify.addHook("onRequest", (_req, _reply, done) => {
        (0, import_store.getAsyncStoreInstance)().run(/* @__PURE__ */ new Map(), done);
      });
      return fastify;
    };
    fastify_default = createFastifyInstance;
  }
});

// src/requestHandlers/utils.ts
var parseBody, mergeMultiValueHeaders;
var init_utils = __esm({
  "src/requestHandlers/utils.ts"() {
    "use strict";
    parseBody = (rawBody) => {
      if (typeof rawBody === "string") {
        return { body: rawBody, isBase64Encoded: false };
      }
      if (rawBody instanceof Buffer) {
        return { body: rawBody.toString("base64"), isBase64Encoded: true };
      }
      return { body: "", isBase64Encoded: false };
    };
    mergeMultiValueHeaders = (headers, multiValueHeaders) => {
      const mergedHeaders = Object.entries(
        headers || {}
      ).reduce((acc, [name, value]) => {
        acc[name.toLowerCase()] = [value];
        return acc;
      }, {});
      Object.entries(multiValueHeaders || {}).forEach(([headerName, values]) => {
        const name = headerName.toLowerCase();
        if (name.toLowerCase() === "set-cookie") {
          mergedHeaders["set-cookie"] = values;
        } else {
          mergedHeaders[name] = [values.join("; ")];
        }
      });
      return mergedHeaders;
    };
  }
});

// src/requestHandlers/awsLambdaFastify.ts
var import_qs, lambdaEventForFastifyRequest, fastifyResponseForLambdaResult, fastifyResponseForLambdaError, requestHandler;
var init_awsLambdaFastify = __esm({
  "src/requestHandlers/awsLambdaFastify.ts"() {
    "use strict";
    import_qs = __toESM(require("qs"));
    init_utils();
    lambdaEventForFastifyRequest = (request) => {
      return {
        httpMethod: request.method,
        headers: request.headers,
        path: request.urlData("path"),
        queryStringParameters: import_qs.default.parse(request.url.split(/\?(.+)/)[1]),
        requestContext: {
          requestId: request.id,
          identity: {
            sourceIp: request.ip
          }
        },
        ...parseBody(request.rawBody || "")
        // adds `body` and `isBase64Encoded`
      };
    };
    fastifyResponseForLambdaResult = (reply, lambdaResult) => {
      const {
        statusCode = 200,
        headers,
        body = "",
        multiValueHeaders
      } = lambdaResult;
      const mergedHeaders = mergeMultiValueHeaders(headers, multiValueHeaders);
      Object.entries(mergedHeaders).forEach(
        ([name, values]) => values.forEach((value) => reply.header(name, value))
      );
      reply.status(statusCode);
      if (lambdaResult.isBase64Encoded) {
        return reply.send(Buffer.from(body, "base64"));
      } else {
        return reply.send(body);
      }
    };
    fastifyResponseForLambdaError = (req, reply, error) => {
      req.log.error(error);
      reply.status(500).send();
    };
    requestHandler = async (req, reply, handler3) => {
      const event = lambdaEventForFastifyRequest(req);
      const handlerCallback = (reply2) => (error, lambdaResult) => {
        if (error) {
          fastifyResponseForLambdaError(req, reply2, error);
          return;
        }
        fastifyResponseForLambdaResult(reply2, lambdaResult);
      };
      const handlerPromise = handler3(
        event,
        // @ts-expect-error - Add support for context: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/0bb210867d16170c4a08d9ce5d132817651a0f80/types/aws-lambda/index.d.ts#L443-L467
        {},
        handlerCallback(reply)
      );
      if (handlerPromise && typeof handlerPromise.then === "function") {
        try {
          const lambdaResponse = await handlerPromise;
          return fastifyResponseForLambdaResult(reply, lambdaResponse);
        } catch (error) {
          return fastifyResponseForLambdaError(req, reply, error);
        }
      }
    };
  }
});

// src/plugins/lambdaLoader.ts
function findApiDistFunctions(cwd = (0, import_project_config3.getPaths)().api.base, options = {}) {
  return import_fast_glob.default.sync("dist/functions/**/*.{ts,js}", {
    cwd,
    deep: 2,
    // We don't support deeply nested api functions, to maximise compatibility with deployment providers
    absolute: true,
    ...options
  });
}
var import_path2, import_chalk, import_fast_glob, import_lodash, import_project_config3, LAMBDA_FUNCTIONS, setLambdaFunctions, loadFunctionsFromDist, lambdaRequestHandler;
var init_lambdaLoader = __esm({
  "src/plugins/lambdaLoader.ts"() {
    "use strict";
    import_path2 = __toESM(require("path"));
    import_chalk = __toESM(require("chalk"));
    import_fast_glob = __toESM(require("fast-glob"));
    import_lodash = require("lodash");
    import_project_config3 = require("@redwoodjs/project-config");
    init_awsLambdaFastify();
    LAMBDA_FUNCTIONS = {};
    setLambdaFunctions = async (foundFunctions) => {
      const tsImport = Date.now();
      console.log(import_chalk.default.dim.italic("Importing Server Functions... "));
      const imports = foundFunctions.map(async (fnPath) => {
        const ts = Date.now();
        const routeName = import_path2.default.basename(fnPath).replace(".js", "");
        const { handler: handler3 } = await import(`file://${fnPath}`);
        LAMBDA_FUNCTIONS[routeName] = handler3;
        if (!handler3) {
          console.warn(
            routeName,
            "at",
            fnPath,
            "does not have a function called handler defined."
          );
        }
        console.log(
          import_chalk.default.magenta("/" + routeName),
          import_chalk.default.dim.italic(Date.now() - ts + " ms")
        );
      });
      await Promise.all(imports);
      console.log(
        import_chalk.default.dim.italic("...Done importing in " + (Date.now() - tsImport) + " ms")
      );
    };
    loadFunctionsFromDist = async (options = {}) => {
      const serverFunctions = findApiDistFunctions(
        (0, import_project_config3.getPaths)().api.base,
        options?.fastGlobOptions
      );
      const i = serverFunctions.findIndex((x) => x.indexOf("graphql") !== -1);
      if (i >= 0) {
        const graphQLFn = serverFunctions.splice(i, 1)[0];
        serverFunctions.unshift(graphQLFn);
      }
      await setLambdaFunctions(serverFunctions);
    };
    lambdaRequestHandler = async (req, reply) => {
      const { routeName } = req.params;
      if (!LAMBDA_FUNCTIONS[routeName]) {
        const errorMessage = `Function "${routeName}" was not found.`;
        req.log.error(errorMessage);
        reply.status(404);
        if (process.env.NODE_ENV === "development") {
          const devError = {
            error: errorMessage,
            availableFunctions: Object.keys(LAMBDA_FUNCTIONS)
          };
          reply.send(devError);
        } else {
          reply.send((0, import_lodash.escape)(errorMessage));
        }
        return;
      }
      return requestHandler(req, reply, LAMBDA_FUNCTIONS[routeName]);
    };
  }
});

// src/plugins/api.ts
async function redwoodFastifyAPI(fastify, opts) {
  const redwoodOptions = opts.redwood ?? {};
  redwoodOptions.apiRootPath ??= "/";
  redwoodOptions.apiRootPath = (0, import_helpers.coerceRootPath)(redwoodOptions.apiRootPath);
  redwoodOptions.fastGlobOptions ??= {};
  redwoodOptions.loadUserConfig ??= false;
  fastify.register(import_url_data.default);
  await fastify.register(import_fastify_raw_body.default);
  fastify.addHook("onRequest", (_req, _reply, done) => {
    (0, import_store2.getAsyncStoreInstance)().run(/* @__PURE__ */ new Map(), done);
  });
  fastify.addContentTypeParser(
    ["application/x-www-form-urlencoded", "multipart/form-data"],
    { parseAs: "string" },
    fastify.defaultTextParser
  );
  if (redwoodOptions.loadUserConfig) {
    const { configureFastify } = await loadFastifyConfig();
    if (configureFastify) {
      await configureFastify(fastify, {
        side: "api",
        apiRootPath: redwoodOptions.apiRootPath
      });
    }
  }
  if (redwoodOptions.configureServer) {
    await redwoodOptions.configureServer(fastify);
  }
  fastify.all(`${redwoodOptions.apiRootPath}:routeName`, lambdaRequestHandler);
  fastify.all(`${redwoodOptions.apiRootPath}:routeName/*`, lambdaRequestHandler);
  await loadFunctionsFromDist({
    fastGlobOptions: redwoodOptions.fastGlobOptions
  });
}
var import_url_data, import_fastify_raw_body, import_store2, import_helpers;
var init_api = __esm({
  "src/plugins/api.ts"() {
    "use strict";
    import_url_data = __toESM(require("@fastify/url-data"));
    import_fastify_raw_body = __toESM(require("fastify-raw-body"));
    import_store2 = require("@redwoodjs/context/dist/store");
    import_helpers = require("@redwoodjs/fastify-web/dist/helpers");
    init_fastify();
    init_lambdaLoader();
  }
});

// src/apiCLIConfigHandler.ts
async function handler(options = {}) {
  const timeStart = Date.now();
  console.log(import_chalk2.default.dim.italic("Starting API Server..."));
  options.apiRootPath = (0, import_fastify_web.coerceRootPath)(options.apiRootPath ?? "/");
  const fastify = await fastify_default();
  fastify.register(redwoodFastifyAPI, {
    redwood: {
      ...options,
      loadUserConfig: true
    }
  });
  options.host ??= getAPIHost();
  options.port ??= getAPIPort();
  await fastify.listen({
    port: options.port,
    host: options.host,
    listenTextResolver: (address2) => {
      if (process.env.NODE_ENV !== "production") {
        address2 = address2.replace(/http:\/\/\[::\]/, "http://localhost");
      }
      return `Server listening at ${address2}`;
    }
  });
  fastify.log.trace(
    { custom: { ...fastify.initialConfig } },
    "Fastify server configuration"
  );
  fastify.log.trace(`Registered plugins
${fastify.printPlugins()}`);
  console.log(import_chalk2.default.dim.italic("Took " + (Date.now() - timeStart) + " ms"));
  let address = fastify.listeningOrigin;
  if (process.env.NODE_ENV !== "production") {
    address = address.replace(/http:\/\/\[::\]/, "http://localhost");
  }
  const apiServer = import_chalk2.default.magenta(`${address}${options.apiRootPath}`);
  const graphqlEndpoint = import_chalk2.default.magenta(`${apiServer}graphql`);
  console.log(`API server listening at ${apiServer}`);
  console.log(`GraphQL endpoint at ${graphqlEndpoint}`);
  process?.send?.("ready");
}
var import_chalk2, import_fastify_web;
var init_apiCLIConfigHandler = __esm({
  "src/apiCLIConfigHandler.ts"() {
    "use strict";
    import_chalk2 = __toESM(require("chalk"));
    import_fastify_web = require("@redwoodjs/fastify-web");
    init_cliHelpers();
    init_fastify();
    init_api();
  }
});

// src/bothCLIConfigHandler.ts
async function handler2(options) {
  const timeStart = Date.now();
  console.log(import_chalk3.default.dim.italic("Starting API and Web Servers..."));
  options.webHost ??= getWebHost();
  options.webPort ??= getWebPort();
  options.apiHost ??= getAPIHost();
  options.apiPort ??= getAPIPort();
  options.apiRootPath = (0, import_fastify_web2.coerceRootPath)(options.apiRootPath ?? "/");
  const apiProxyTarget = [
    "http://",
    options.apiHost.includes(":") ? `[${options.apiHost}]` : options.apiHost,
    ":",
    options.apiPort,
    options.apiRootPath
  ].join("");
  const webFastify = await fastify_default();
  webFastify.register(import_fastify_web2.redwoodFastifyWeb, {
    redwood: {
      apiProxyTarget
    }
  });
  const apiFastify = await fastify_default();
  apiFastify.register(redwoodFastifyAPI, {
    redwood: {
      apiRootPath: options.apiRootPath,
      loadUserConfig: true
    }
  });
  await webFastify.listen({
    port: options.webPort,
    host: options.webHost,
    listenTextResolver: getListenTextResolver("Web")
  });
  webFastify.log.trace(
    { custom: { ...webFastify.initialConfig } },
    "Fastify server configuration"
  );
  webFastify.log.trace(`Registered plugins
${webFastify.printPlugins()}`);
  await apiFastify.listen({
    port: options.apiPort,
    host: options.apiHost,
    listenTextResolver: getListenTextResolver("API")
  });
  apiFastify.log.trace(
    { custom: { ...apiFastify.initialConfig } },
    "Fastify server configuration"
  );
  apiFastify.log.trace(`Registered plugins
${apiFastify.printPlugins()}`);
  console.log(import_chalk3.default.dim.italic("Took " + (Date.now() - timeStart) + " ms"));
  const webServer = import_chalk3.default.green(webFastify.listeningOrigin);
  const apiServer = import_chalk3.default.magenta(
    `${apiFastify.listeningOrigin}${options.apiRootPath}`
  );
  const graphqlEndpoint = import_chalk3.default.magenta(`${apiServer}graphql`);
  console.log(`Web server listening at ${webServer}`);
  console.log(`API server listening at ${apiServer}`);
  console.log(`GraphQL endpoint at ${graphqlEndpoint}`);
  process?.send?.("ready");
}
function getListenTextResolver(side) {
  return (address) => {
    if (process.env.NODE_ENV !== "production") {
      address = address.replace(/http:\/\/\[::\]/, "http://localhost");
    }
    return `${side} server listening at ${address}`;
  };
}
var import_chalk3, import_fastify_web2;
var init_bothCLIConfigHandler = __esm({
  "src/bothCLIConfigHandler.ts"() {
    "use strict";
    import_chalk3 = __toESM(require("chalk"));
    import_fastify_web2 = require("@redwoodjs/fastify-web");
    init_cliHelpers();
    init_fastify();
    init_api();
  }
});

// src/bin.ts
var import_path3 = __toESM(require("path"));
var import_dotenv_defaults = require("dotenv-defaults");
var import_helpers2 = require("yargs/helpers");
var import_yargs = __toESM(require("yargs/yargs"));
var import_project_config4 = require("@redwoodjs/project-config");
var import_web_server = require("@redwoodjs/web-server");

// src/apiCLIConfig.ts
var description = "Start a server for serving the api side";
function builder(yargs2) {
  yargs2.options({
    port: {
      description: "The port to listen at",
      type: "number",
      alias: "p"
    },
    host: {
      description: "The host to listen at. Note that you most likely want this to be '0.0.0.0' in production",
      type: "string"
    },
    apiRootPath: {
      description: "Root path where your api functions are served",
      type: "string",
      alias: ["api-root-path", "rootPath", "root-path"],
      default: "/"
    },
    // This became a no-op in v7 because env files weren't loaded by default
    // but removing it would break yargs parsing for older projects,
    // so leaving it here so that yargs doesn't throw an error
    loadEnvFiles: {
      hidden: true
    }
  });
}

// src/bin.ts
init_apiCLIConfigHandler();

// src/bothCLIConfig.ts
var description2 = "Start a server for serving the api and web sides";
function builder2(yargs2) {
  yargs2.options({
    webPort: {
      description: "The port for the web server to listen on",
      type: "number",
      alias: ["web-port"]
    },
    webHost: {
      description: "The host for the web server to listen on. Note that you most likely want this to be '0.0.0.0' in production",
      type: "string",
      alias: ["web-host"]
    },
    apiPort: {
      description: "The port for the api server to listen on",
      type: "number",
      alias: ["api-port"]
    },
    apiHost: {
      description: "The host for the api server to listen on. Note that you most likely want this to be '0.0.0.0' in production",
      type: "string",
      alias: ["api-host"]
    },
    apiRootPath: {
      description: "Root path where your api functions are served",
      type: "string",
      alias: ["api-root-path", "rootPath", "root-path"],
      default: "/"
    }
  });
}

// src/bin.ts
init_bothCLIConfigHandler();
if (!process.env.REDWOOD_ENV_FILES_LOADED) {
  (0, import_dotenv_defaults.config)({
    path: import_path3.default.join((0, import_project_config4.getPaths)().base, ".env"),
    defaults: import_path3.default.join((0, import_project_config4.getPaths)().base, ".env.defaults"),
    multiline: true
  });
  process.env.REDWOOD_ENV_FILES_LOADED = "true";
}
process.env.NODE_ENV ??= "production";
(0, import_yargs.default)((0, import_helpers2.hideBin)(process.argv)).scriptName("rw-server").strict().alias("h", "help").alias("v", "version").command(
  "$0",
  description2,
  // @ts-expect-error The yargs types seem wrong; it's ok for builder to be a function
  builder2,
  handler2
).command(
  "api",
  description,
  // @ts-expect-error The yargs types seem wrong; it's ok for builder to be a function
  builder,
  handler
).command(
  "web",
  import_web_server.description,
  // @ts-expect-error The yargs types seem wrong; it's ok for builder to be a function
  import_web_server.builder,
  import_web_server.handler
).parse();
