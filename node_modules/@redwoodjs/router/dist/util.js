"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.analyzeRoutes = analyzeRoutes;
exports.createNamedContext = createNamedContext;
exports.flattenAll = flattenAll;
exports.flattenSearchParams = flattenSearchParams;
exports.getRouteRegexAndParams = getRouteRegexAndParams;
exports.inIframe = inIframe;
exports.isSpec = isSpec;
exports.matchPath = matchPath;
exports.normalizePage = normalizePage;
exports.paramsForRoute = paramsForRoute;
exports.parseSearch = parseSearch;
exports.replaceParams = replaceParams;
exports.validatePath = validatePath;
var _flatMap = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/flat-map"));
var _matchAll = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/match-all"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));
var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));
var _urlSearchParams = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/url-search-params"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/keys"));
var _startsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/starts-with"));
var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/index-of"));
var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));
var _keys2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));
var _fromEntries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/from-entries"));
var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/entries"));
var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/is-array"));
var _at = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/at"));
var _react = _interopRequireWildcard(require("react"));
var _routeValidators = require("./route-validators");
var _Set = require("./Set");
/** Create a React Context with the given name. */
function createNamedContext(name, defaultValue) {
  const Ctx = /*#__PURE__*/_react.default.createContext(defaultValue);
  Ctx.displayName = name;
  return Ctx;
}
function flattenAll(children) {
  const childrenArray = _react.Children.toArray(children);
  return (0, _flatMap.default)(childrenArray).call(childrenArray, child => {
    if ( /*#__PURE__*/(0, _react.isValidElement)(child) && child.props.children) {
      return [child, ...flattenAll(child.props.children)];
    }
    return [child];
  });
}
/**
 * Get param name, type, and match for a route.
 *
 *  '/blog/{year}/{month}/{day:Int}/{filePath...}'
 *   => [
 *        ['year',     'String', '{year}'],
 *        ['month',    'String', '{month}'],
 *        ['day',      'Int',    '{day:Int}'],
 *        ['filePath', 'Glob',   '{filePath...}']
 *      ]
 *
 * Only exported to be able to test it
 */
function paramsForRoute(route) {
  var _context;
  // Match the strings between `{` and `}`.
  const params = [...(0, _matchAll.default)(route).call(route, /\{([^}]+)\}/g)];
  return (0, _map.default)(_context = (0, _map.default)(params).call(params, match => match[1])).call(_context, match => {
    const parts = match.split(':');

    // Normalize the name
    let name = parts[0];
    if ((0, _slice.default)(name).call(name, -3) === '...') {
      // Globs have their ellipsis removed
      name = (0, _slice.default)(name).call(name, 0, -3);
    }

    // Determine the type
    let type = parts[1];
    if (!type) {
      // Strings and Globs are implicit in the syntax
      type = (0, _slice.default)(match).call(match, -3) === '...' ? 'Glob' : 'String';
    }
    return [name, type, `{${match}}`];
  });
}
/** Definitions of the core param types. */
const coreParamTypes = {
  String: {
    match: /[^/]+/
  },
  Int: {
    match: /\d+/,
    parse: Number
  },
  Float: {
    match: /[-+]?(?:\d*\.?\d+|\d+\.?\d*)(?:[eE][-+]?\d+)?/,
    parse: Number
  },
  Boolean: {
    match: /true|false/,
    parse: boolAsString => boolAsString === 'true'
  },
  Glob: {
    match: /.*/
  }
};
/**
 * Determine if the given route is a match for the given pathname. If so,
 * extract any named params and return them in an object.
 *
 * route         - The route path as specified in the <Route path={...} />
 * pathname      - The pathname from the window.location.
 * paramTypes    - The object containing all param type definitions.
 * matchSubPaths - Also match sub routes
 *
 * Examples:
 *
 *  matchPath('/blog/{year}/{month}/{day}', '/blog/2019/12/07')
 *  => { match: true, params: { year: '2019', month: '12', day: '07' }}
 *
 *  matchPath('/about', '/')
 *  => { match: false }
 *
 *  matchPath('/post/{id:Int}', '/post/7')
 *  => { match: true, params: { id: 7 }}
 *
 *  matchPath('/post/1', '/post/', { matchSubPaths: true })
 *  => { match: true, params: {} }
 */
function matchPath(routeDefinition, pathname) {
  var _context2;
  let {
    userParamTypes,
    matchSubPaths
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    userParamTypes: {},
    matchSubPaths: false
  };
  // Get the names and the transform types for the given route.
  const allParamTypes = {
    ...coreParamTypes,
    ...userParamTypes
  };
  const {
    matchRegex,
    routeParams: routeParamsDefinition
  } = getRouteRegexAndParams(routeDefinition, {
    matchSubPaths,
    allParamTypes
  });

  // Does the `pathname` match the route?
  const matches = [...(0, _matchAll.default)(pathname).call(pathname, matchRegex)];
  if (matches.length === 0) {
    return {
      match: false
    };
  }
  // Map extracted values to their param name, casting the value if needed
  const providedParams = (0, _slice.default)(_context2 = matches[0]).call(_context2, 1);

  // @NOTE: refers to definition e.g. '/page/{id}', not the actual params
  if (routeParamsDefinition.length > 0) {
    const params = (0, _reduce.default)(providedParams).call(providedParams, (acc, value, index) => {
      const [name, transformName] = routeParamsDefinition[index];
      const typeInfo = allParamTypes[transformName];
      let transformedValue = value;
      if (typeof typeInfo?.parse === 'function') {
        transformedValue = typeInfo.parse(value);
      }
      return {
        ...acc,
        [name]: transformedValue
      };
    }, {});
    return {
      match: true,
      params
    };
  }
  return {
    match: true
  };
}
/**
 *  This function will return a regex for each route path i.e. /blog/{year}/{month}/{day}
 *  will return a regex like /blog/([^/$1*]+)/([^/$1*]+)/([^/$1*]+)
 *
 * @returns
 */

function getRouteRegexAndParams(route) {
  let {
    matchSubPaths = false,
    allParamTypes = coreParamTypes
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let typeMatchingRoute = route;
  const routeParams = paramsForRoute(route);

  // Map all params from the route to their type `match` regexp to create a
  // "type-matching route" regexp
  // /recipe/{id} -> /recipe/([^/$1*]+)
  for (const [_name, type, match] of routeParams) {
    // `undefined` matcher if `type` is not supported
    const matcher = allParamTypes[type]?.match;

    // Get the regex as a string, or default regexp if `match` is not specified
    const typeRegexp = matcher?.source || '[^/]+';
    typeMatchingRoute = typeMatchingRoute.replace(match, `(${typeRegexp})`);
  }
  const matchRegex = matchSubPaths ? new RegExp(`^${typeMatchingRoute}(?:/.*)?$`, 'g') : new RegExp(`^${typeMatchingRoute}$`, 'g');
  const matchRegexString = matchSubPaths ? `^${typeMatchingRoute}(?:/.*)?$` : `^${typeMatchingRoute}$`;
  return {
    matchRegex,
    routeParams,
    matchRegexString
  };
}

/**
 * Parse the given search string into key/value pairs and return them in an
 * object.
 *
 * Examples:
 *
 *  parseSearch('?key1=val1&key2=val2')
 *  => { key1: 'val1', key2: 'val2' }
 *
 * @fixme
 * This utility ignores keys with multiple values such as `?foo=1&foo=2`.
 */
function parseSearch(search) {
  var _context3;
  const searchParams = new _urlSearchParams.default(search);
  return (0, _reduce.default)(_context3 = [...(0, _keys.default)(searchParams).call(searchParams)]).call(_context3, (params, key) => ({
    ...params,
    [key]: searchParams.get(key)
  }), {});
}

/**
 * Validate a path to make sure it follows the router's rules. If any problems
 * are found, a descriptive Error will be thrown, as problems with routes are
 * critical enough to be considered fatal.
 */
function validatePath(path, routeName) {
  // Check that path begins with a slash.
  if (!(0, _startsWith.default)(path).call(path, '/')) {
    throw new Error(`Route path for ${routeName} does not begin with a slash: "${path}"`);
  }
  if ((0, _indexOf.default)(path).call(path, ' ') >= 0) {
    throw new Error(`Route path for ${routeName} contains spaces: "${path}"`);
  }
  if (/{(?:ref|key)(?::|})/.test(path)) {
    throw new Error([`Route for ${routeName} contains ref or key as a path parameter: "${path}"`, "`ref` and `key` shouldn't be used as path parameters because they're special React props.", 'You can fix this by renaming the path parameter.'].join('\n'));
  }

  // Check for duplicate named params.
  const matches = (0, _matchAll.default)(path).call(path, /\{([^}]+)\}/g);
  const memo = {};
  for (const match of matches) {
    // Extract the param's name to make sure there aren't any duplicates
    const param = match[1].split(':')[0];
    if (memo[param]) {
      throw new Error(`Route path contains duplicate parameter: "${path}"`);
    } else {
      memo[param] = true;
    }
  }
}

/**
 * Take a given route path and replace any named parameters with those in the
 * given args object. Any extra params not used in the path will be appended
 * as key=value pairs in the search part.
 *
 * Examples:
 *
 *   replaceParams('/tags/{tag}', { tag: 'code', extra: 'foo' })
 *   => '/tags/code?extra=foo
 */
function replaceParams(route) {
  var _context4;
  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const params = paramsForRoute(route);
  let path = route;

  // Replace all params in the route with their values
  (0, _forEach.default)(params).call(params, param => {
    const [name, _type, match] = param;
    const value = args[name];
    if (value !== undefined) {
      path = path.replace(match, value);
    } else {
      throw new Error(`Missing parameter '${name}' for route '${route}' when generating a navigation URL.`);
    }
  });
  const paramNames = (0, _map.default)(params).call(params, param => param[0]);
  const extraArgKeys = (0, _filter.default)(_context4 = (0, _keys2.default)(args)).call(_context4, x => !(0, _includes.default)(paramNames).call(paramNames, x));

  // Prepare any unnamed params to be be appended as search params.
  const queryParams = [];
  (0, _forEach.default)(extraArgKeys).call(extraArgKeys, key => {
    queryParams.push(`${key}=${args[key]}`);
  });

  // Append any unnamed params as search params.
  if (extraArgKeys.length) {
    const extraArgs = (0, _fromEntries.default)((0, _map.default)(extraArgKeys).call(extraArgKeys, key => [key, `${args[key]}`]));
    path += `?${new _urlSearchParams.default(extraArgs).toString()}`;
  }
  return path;
}
/**
 * Returns a flat array of search params
 *
 * `useMatch` hook options `searchParams` requires a flat array
 *
 * Example:
 * ```
 *   parseSearch('?key1=val1&key2=val2')
 *   => { key1: 'val1', key2: 'val2' }
 *
 *   flattenSearchParams(parseSearch('?key1=val1&key2=val2'))
 *   => [ { key1: 'val1' }, { key2: 'val2' } ]
 * ```
 */
function flattenSearchParams(queryString) {
  const searchParams = [];
  for (const [key, value] of (0, _entries.default)(parseSearch(queryString))) {
    searchParams.push({
      [key]: value
    });
  }
  return searchParams;
}
function isSpec(specOrPage) {
  return specOrPage.LazyComponent !== undefined;
}

/**
 * Pages can be imported automatically or manually. Automatic imports are actually
 * objects and take the following form (which we call a 'spec'):
 *
 *   const WhateverPage = {
 *     name: 'WhateverPage',
 *     LazyComponent: lazy(() => import('src/pages/WhateverPage'))
 *     prerenderLoader: ...
 *   }
 *
 * Manual imports simply load the page:
 *
 *   import WhateverPage from 'src/pages/WhateverPage'
 *
 * Before passing a "page" to the PageLoader, we will normalize the manually
 * imported version into a spec.
 */
function normalizePage(specOrPage) {
  if (isSpec(specOrPage)) {
    // Already a spec, just return it.
    return specOrPage;
  }

  // Wrap the Page in a fresh spec, and put it in a promise to emulate
  // an async module import.
  return {
    name: specOrPage.name,
    prerenderLoader: () => ({
      default: specOrPage
    }),
    LazyComponent: specOrPage
  };
}

/**
 * Detect if we're in an iframe.
 *
 * From https://stackoverflow.com/questions/326069/how-to-identify-if-a-webpage-is-being-loaded-inside-an-iframe-or-directly-into-t
 */
function inIframe() {
  try {
    return global?.self !== global?.top;
  } catch (e) {
    return true;
  }
}

// This is essentially the same as RouteProps
// but it allows for page and redirect to be null or undefined
// Keeping the shape consistent makes it easier to use

// Not using AvailableRoutes because the type is generated in the user's project
// We can't index it correctly in the framework

function analyzeRoutes(children, _ref) {
  let {
    currentPathName,
    userParamTypes
  } = _ref;
  const pathRouteMap = {};
  const namedRoutesMap = {};
  let hasHomeRoute = false;
  let NotFoundPage;
  let activeRoutePath;
  // Assign ids to all sets found.
  // Because Sets are virtually rendered we can use this id as a key to
  // properly manage re-rendering when using the same wrapper Component for
  // different Sets
  //
  // Example:
  // <Router>
  //   <Set wrap={SetContextProvider}> // id: '1'
  //     <Route path="/" page={HomePage} name="home" />
  //     <Route path="/ctx-1-page" page={Ctx1Page} name="ctx1" />
  //     <Set wrap={Ctx2Layout}> // id: '1.1'
  //       <Route path="/ctx-2-page" page={Ctx2Page} name="ctx2" />
  //     </Set>
  //   </Set>
  //   <Set wrap={SetContextProvider}> // id: '2'
  //     <Route path="/ctx-3-page" page={Ctx3Page} name="ctx3" />
  //   </Set>
  // </Router>

  const recurseThroughRouter = _ref2 => {
    let {
      nodes,
      whileLoadingPageFromSet,
      sets: previousSets = []
    } = _ref2;
    let nextSetId = 0;
    (0, _forEach.default)(nodes).call(nodes, node => {
      if ((0, _routeValidators.isValidRoute)(node)) {
        // Rename for readability
        const route = node;

        // We don't add not found pages to our list of named routes
        if ((0, _routeValidators.isNotFoundRoute)(route)) {
          NotFoundPage = route.props.page;
          // Don't add notFound routes to the maps, and exit early
          // @TODO: We may need to add it to the map, because you can in
          // theory wrap a notfound page in a Set wrapper
          return;
        }

        // Used to decide whether to display SplashPage
        if (route.props.path === '/') {
          hasHomeRoute = true;
        }
        if ((0, _routeValidators.isRedirectRoute)(route)) {
          const {
            name,
            redirect,
            path
          } = route.props;

          // The name is just for showing a human-readable error message
          validatePath(path, name || path);
          const {
            match
          } = matchPath(path, currentPathName, {
            userParamTypes
          });

          // Check if we already have an active path to only return the first match
          if (match && !activeRoutePath) {
            activeRoutePath = path;
          }

          // If the redirect route doesn't have a name, no need to add it to the map
          pathRouteMap[path] = {
            redirect,
            name: name || null,
            path,
            page: null,
            // Redirects don't need pages. We set this to null for consistency
            sets: previousSets
          };
          if (name) {
            namedRoutesMap[name] = function () {
              let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              return replaceParams(path, args);
            };
          }
        }
        if ((0, _routeValidators.isStandardRoute)(route)) {
          const {
            name,
            path,
            page
          } = route.props;
          // Will throw if invalid path
          validatePath(path, name);
          const {
            match
          } = matchPath(path, currentPathName, {
            userParamTypes
          });

          // Check if we already have an active path to only return the first match
          if (match && !activeRoutePath) {
            activeRoutePath = path;
          }

          // e.g. namePathMap['homePage'] = { name: 'homePage', path: '/home', ...}
          // We always set all the keys, even if their values are null/undefined for consistency
          pathRouteMap[path] = {
            redirect: null,
            name,
            path,
            whileLoadingPage: route.props.whileLoadingPage || whileLoadingPageFromSet,
            page,
            sets: previousSets
          };

          // e.g. namedRoutesMap.homePage = () => '/home'
          namedRoutesMap[name] = function () {
            let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return replaceParams(path, args);
          };
        }
      }

      // @NOTE: A <PrivateSet> is also a Set
      if ((0, _Set.isSetNode)(node)) {
        const {
          children,
          whileLoadingPage: whileLoadingPageFromCurrentSet,
          wrap: wrapFromCurrentSet,
          ...otherPropsFromCurrentSet
        } = node.props;
        let wrapperComponentsArray = [];
        if (wrapFromCurrentSet) {
          wrapperComponentsArray = (0, _isArray.default)(wrapFromCurrentSet) ? wrapFromCurrentSet : [wrapFromCurrentSet];
        }
        nextSetId = nextSetId + 1;
        recurseThroughRouter({
          nodes: _react.Children.toArray(children),
          // When there's a whileLoadingPage prop on a Set, we pass it down to all its children
          // If the parent node was also a Set with whileLoadingPage, we pass it down. The child's whileLoadingPage
          // will always take precedence over the parent's
          whileLoadingPageFromSet: whileLoadingPageFromCurrentSet || whileLoadingPageFromSet,
          sets: [...previousSets, {
            id: createSetId(nextSetId, previousSets),
            wrappers: wrapperComponentsArray,
            isPrivate: (0, _Set.isPrivateSetNode)(node) ||
            // The following two conditions can be removed when we remove
            // the deprecated private prop
            (0, _Set.isPrivateNode)(node) || !!otherPropsFromCurrentSet.private,
            props: otherPropsFromCurrentSet
          }]
        });
      }
    });
  };
  recurseThroughRouter({
    nodes: _react.Children.toArray(children)
  });
  return {
    pathRouteMap,
    namedRoutesMap,
    hasHomeRoute,
    NotFoundPage,
    activeRoutePath
  };
}
function createSetId(nextSetId, previousSets) {
  const firstLevel = previousSets.length === 0;
  if (firstLevel) {
    // For the first level we don't want to add any dots ('.') to the id like
    // we do for all other levels
    return nextSetId.toString();
  }
  return (0, _at.default)(previousSets).call(previousSets, -1)?.id + '.' + nextSetId;
}