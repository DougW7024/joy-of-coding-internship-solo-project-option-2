"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.useMatch = void 0;
var _urlSearchParams = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/url-search-params"));
var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/some"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));
var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/entries"));
var _every = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/every"));
var _location = require("./location");
var _util = require("./util");
/**
 * Returns an object of { match: boolean; params: Record<string, unknown>; }
 * If the path matches the current location `match` will be true.
 * Params will be an object of the matched params, if there are any.
 *
 * Provide routeParams options to match specific route param values
 * Provide searchParams options to match the current location.search
 *
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 *
 * Examples:
 *
 * Match search params key existence
 * const match = useMatch('/about', { searchParams: ['category', 'page'] })
 *
 * Match search params key and value
 * const match = useMatch('/items', { searchParams: [{page: 2}, {category: 'book'}] })
 *
 * Mix match
 * const match = useMatch('/list', { searchParams: [{page: 2}, 'gtm'] })
 *
 * Match sub paths
 * const match = useMatch('/product', { matchSubPaths: true })
 *
 * Match only specific route param values
 * const match = useMatch('/product/{category}/{id}', { routeParams: { category: 'shirts' } })
 */
const useMatch = (routePath, options) => {
  const location = (0, _location.useLocation)();
  if (!location) {
    return {
      match: false
    };
  }
  if (options?.searchParams) {
    var _context;
    const locationParams = new _urlSearchParams.default(location.search);
    const hasUnmatched = (0, _some.default)(_context = options.searchParams).call(_context, param => {
      if (typeof param === 'string') {
        return !locationParams.has(param);
      } else {
        var _context2;
        return (0, _some.default)(_context2 = (0, _keys.default)(param)).call(_context2, key => param[key] != locationParams.get(key));
      }
    });
    if (hasUnmatched) {
      return {
        match: false
      };
    }
  }
  const matchInfo = (0, _util.matchPath)(routePath, location.pathname, {
    matchSubPaths: options?.matchSubPaths
  });
  if (!matchInfo.match) {
    return {
      match: false
    };
  }
  const routeParams = (0, _entries.default)(options?.routeParams || {});
  if (routeParams.length > 0) {
    if (!isMatchWithParams(matchInfo) || !matchInfo.params) {
      return {
        match: false
      };
    }

    // If paramValues were given, they must all match
    const isParamMatch = (0, _every.default)(routeParams).call(routeParams, _ref => {
      let [key, value] = _ref;
      return matchInfo.params[key] === value;
    });
    if (!isParamMatch) {
      return {
        match: false
      };
    }
  }
  return matchInfo;
};
exports.useMatch = useMatch;
function isMatchWithParams(match) {
  return match !== null && typeof match === 'object' && 'params' in match;
}