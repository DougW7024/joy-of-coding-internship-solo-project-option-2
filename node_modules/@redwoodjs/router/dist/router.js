"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
_Object$defineProperty(exports, "PageType", {
  enumerable: true,
  get: function () {
    return _routeValidators.PageType;
  }
});
exports.Route = Route;
exports.Router = void 0;
_Object$defineProperty(exports, "isRoute", {
  enumerable: true,
  get: function () {
    return _routeValidators.isValidRoute;
  }
});
exports.routes = void 0;
var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/assign"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));
var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find"));
var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/values"));
var _reduceRight = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce-right"));
var _react = _interopRequireWildcard(require("react"));
var _activeRouteLoader = require("./active-route-loader");
var _AuthenticatedRoute = require("./AuthenticatedRoute");
var _links = require("./links");
var _location = require("./location");
var _PageLoadingContext = require("./PageLoadingContext");
var _params = require("./params");
var _routeValidators = require("./route-validators");
var _routerContext = require("./router-context");
var _splashPage = require("./splash-page");
var _util = require("./util");
var _jsxRuntime = require("react/jsx-runtime");
// namedRoutes is populated at run-time by iterating over the `<Route />`
// components, and appending them to this object.
// Has to be `const`, or there'll be a race condition with imports in users'
// projects
const namedRoutes = exports.routes = {};

/**
 * Route is now a "virtual" component
 * it is actually never rendered. All the page loading logic happens in active-route-loader
 * and all the validation happens within utility functions called from the Router
 */

function Route(_props) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {});
}
const Router = _ref => {
  let {
    useAuth,
    paramTypes,
    pageLoadingDelay,
    trailingSlashes = 'never',
    children
  } = _ref;
  return (
    /*#__PURE__*/
    // Level 1/3 (outer-most)
    // Wrap it in the provider so that useLocation can be used
    (0, _jsxRuntime.jsx)(_location.LocationProvider, {
      trailingSlashes: trailingSlashes,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(LocationAwareRouter, {
        useAuth: useAuth,
        paramTypes: paramTypes,
        pageLoadingDelay: pageLoadingDelay,
        children: children
      })
    })
  );
};
exports.Router = Router;
const LocationAwareRouter = _ref2 => {
  let {
    useAuth,
    paramTypes,
    pageLoadingDelay,
    children
  } = _ref2;
  const location = (0, _location.useLocation)();
  const analyzeRoutesResult = (0, _react.useMemo)(() => {
    return (0, _util.analyzeRoutes)(children, {
      currentPathName: location.pathname,
      // @TODO We haven't handled this with SSR/Streaming yet.
      // May need a babel plugin to extract userParamTypes from Routes.tsx
      userParamTypes: paramTypes
    });
  }, [location.pathname, children, paramTypes]);
  const {
    pathRouteMap,
    hasHomeRoute,
    namedRoutesMap,
    NotFoundPage,
    activeRoutePath
  } = analyzeRoutesResult;

  // Assign namedRoutes so it can be imported like import {routes} from 'rwjs/router'
  // Note that the value changes at runtime
  (0, _assign.default)(namedRoutes, namedRoutesMap);

  // The user has not generated routes if the only route that exists is the
  // not found page, and that page is not part of the namedRoutes object
  const hasGeneratedRoutes = (0, _keys.default)(namedRoutes).length > 0;
  const shouldShowSplash = !hasHomeRoute && location.pathname === '/' || !hasGeneratedRoutes;
  if (shouldShowSplash && typeof _splashPage.SplashPage !== 'undefined') {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_splashPage.SplashPage, {
      hasGeneratedRoutes: hasGeneratedRoutes,
      allStandardRoutes: pathRouteMap
    });
  }

  // Render 404 page if no route matches
  if (!activeRoutePath) {
    if (NotFoundPage) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_routerContext.RouterContextProvider, {
        useAuth: useAuth,
        paramTypes: paramTypes,
        routes: analyzeRoutesResult,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_params.ParamsProvider, {
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_PageLoadingContext.PageLoadingContextProvider, {
            delay: pageLoadingDelay,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_activeRouteLoader.ActiveRouteLoader, {
              spec: (0, _util.normalizePage)(NotFoundPage),
              path: location.pathname
            })
          })
        })
      });
    }
    return null;
  }
  const {
    path,
    page,
    name,
    redirect,
    whileLoadingPage,
    sets
  } = pathRouteMap[activeRoutePath];
  if (!path) {
    throw new Error(`Route "${name}" needs to specify a path`);
  }

  // Check for issues with the path.
  (0, _util.validatePath)(path, name || path);
  const {
    params: pathParams
  } = (0, _util.matchPath)(path, location.pathname, {
    userParamTypes: paramTypes
  });
  const searchParams = (0, _util.parseSearch)(location.search);
  const allParams = {
    ...searchParams,
    ...pathParams
  };
  let redirectPath = undefined;
  if (redirect) {
    if (redirect[0] === '/') {
      redirectPath = (0, _util.replaceParams)(redirect, allParams);
    } else {
      var _context;
      const redirectRouteObject = (0, _find.default)(_context = (0, _values.default)(pathRouteMap)).call(_context, route => route.name === redirect);
      if (!redirectRouteObject) {
        throw new Error(`Redirect target route "${redirect}" does not exist for route "${name}"`);
      }
      redirectPath = (0, _util.replaceParams)(redirectRouteObject.path, allParams);
    }
  }

  // Level 2/3 (LocationAwareRouter)
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_routerContext.RouterContextProvider, {
    useAuth: useAuth,
    paramTypes: paramTypes,
    routes: analyzeRoutesResult,
    activeRouteName: name,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_params.ParamsProvider, {
      allParams: allParams,
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_PageLoadingContext.PageLoadingContextProvider, {
        delay: pageLoadingDelay,
        children: [redirectPath && /*#__PURE__*/(0, _jsxRuntime.jsx)(_links.Redirect, {
          to: redirectPath
        }), !redirectPath && page && /*#__PURE__*/(0, _jsxRuntime.jsx)(WrappedPage, {
          sets: sets,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_activeRouteLoader.ActiveRouteLoader, {
            path: path,
            spec: (0, _util.normalizePage)(page),
            params: allParams,
            whileLoadingPage: whileLoadingPage
          })
        })]
      })
    })
  });
};
/**
 * This is effectively a Set (without auth-related code)
 *
 * This means that the <Set> and <PrivateSet> components become "virtual"
 * i.e. they are never actually Rendered, but their props are extracted by the
 * analyze routes function.
 *
 * This is so that we can have all the information up front in the routes-manifest
 * for SSR, but also so that we only do one loop of all the Routes.
 */
const WrappedPage = /*#__PURE__*/(0, _react.memo)(_ref3 => {
  let {
    sets,
    children
  } = _ref3;
  // @NOTE: don't mutate the wrappers array, it causes full page re-renders
  // Instead just create a new array with the AuthenticatedRoute wrapper

  if (!sets || sets.length === 0) {
    return children;
  }
  return (0, _reduceRight.default)(sets).call(sets, (acc, set) => {
    var _context2;
    // For each set in `sets`, if you have `<Set wrap={[a,b,c]} p="p" />` then
    // this will return
    // <a p="p"><b p="p"><c p="p"><routeLoaderElement /></c></b></a>
    // If you have `<PrivateSet wrap={[a,b,c]} p="p" />` instead it will return
    // <AuthenticatedRoute>
    //   <a p="p"><b p="p"><c p="p"><routeLoaderElement /></c></b></a>
    // </AuthenticatedRoute>

    // Bundle up all the wrappers into a single element with each wrapper as a
    // child of the previous (that's why we do reduceRight)
    let wrapped = (0, _reduceRight.default)(_context2 = set.wrappers).call(_context2, (acc, Wrapper, index) => {
      return /*#__PURE__*/_react.default.createElement(Wrapper, {
        ...set.props,
        key: set.id + '-' + index
      }, acc);
    }, acc);

    // If set is private, wrap it in AuthenticatedRoute
    if (set.isPrivate) {
      const unauthenticated = set.props.unauthenticated;
      if (!unauthenticated || typeof unauthenticated !== 'string') {
        throw new Error('You must specify an `unauthenticated` route when using PrivateSet');
      }

      // We do this last, to make sure that none of the wrapper elements are
      // rendered if the user isn't authenticated
      wrapped = /*#__PURE__*/(0, _jsxRuntime.jsx)(_AuthenticatedRoute.AuthenticatedRoute, {
        ...set.props,
        unauthenticated: unauthenticated,
        children: wrapped
      });
    }
    return wrapped;
  }, children);
});