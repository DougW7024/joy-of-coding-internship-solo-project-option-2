"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
_Object$defineProperty(exports, "getDirectiveName", {
  enumerable: true,
  get: function () {
    return _graphqlServer.getDirectiveName;
  }
});
exports.mockRedwoodDirective = void 0;
var _context = require("@redwoodjs/context");
var _graphqlServer = require("@redwoodjs/graphql-server");
// @NOTE: overloaded interface

// Overload this definition for transformers

/**
 * @description
 *
 * Used for writing both synchronous and asynchronous directive tests e.g.
 *
 * - Transformer directives can be passed mockedResolvedValue
 * - Validator directives should check for errors thrown in certain situations
 * - Can provide args, directiveArgs and context to mock directive execution
 *
 * @example
 *
 * Synchronous transformer directive:
 *
 * ```ts
 * const mockExecution = mockRedwoodDirective(myTransformer, {
 *   context: currentUser,
 *   mockedResolvedValue: 'Original Value',
 * })
 *
 * expect(mockExecution).not.toThrow()
 * expect(mockExecution()).toEqual('Transformed Value')
 * ```ts
 *
 * @example
 *
 * Asynchronous transformer directive:
 *
 * ```ts
 * const mockExecution = mockRedwoodDirective(myTransformer, {
 *   context: currentUser,
 *   mockedResolvedValue: 'Original Value',
 * })
 *
 * await expect(mockExecution).resolves.not.toThrow()
 * await expect(mockExecution()).resolves.toEqual('Transformed Value')
 * ```
 */
const mockRedwoodDirective = (directive, executionMock) => {
  const {
    directiveArgs,
    context,
    ...others
  } = executionMock;
  if (directive.onResolvedValue.constructor.name === 'AsyncFunction') {
    return async () => {
      if (context !== undefined) {
        (0, _context.setContext)(context);
      }
      if (directive.type === _graphqlServer.DirectiveType.TRANSFORMER) {
        const {
          mockedResolvedValue
        } = others;
        return directive.onResolvedValue({
          resolvedValue: mockedResolvedValue,
          directiveArgs: directiveArgs ?? {},
          context: _context.context,
          ...others
        });
      } else {
        await directive.onResolvedValue({
          directiveArgs: directiveArgs ?? {},
          context: _context.context,
          ...others
        });
      }
    };
  }
  return () => {
    if (context !== undefined) {
      (0, _context.setContext)(context);
    }
    if (directive.type === _graphqlServer.DirectiveType.TRANSFORMER) {
      const {
        mockedResolvedValue
      } = others;
      return directive.onResolvedValue({
        resolvedValue: mockedResolvedValue,
        directiveArgs: directiveArgs ?? {},
        context: _context.context,
        ...others
      });
    } else {
      directive.onResolvedValue({
        directiveArgs: directiveArgs ?? {},
        context: _context.context,
        ...others
      });
    }
  };
};
exports.mockRedwoodDirective = mockRedwoodDirective;